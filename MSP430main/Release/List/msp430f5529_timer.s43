///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.12.1.987/W32 for MSP430          01/Nov/2018  12:43:44
// Copyright 1996-2018 IAR Systems AB.
// PC-locked license - IAR Embedded Workbench for Texas Instruments MSP430
//
//    __rt_version  =  3
//    __double_size =  32
//    __reg_r4      =  free
//    __reg_r5      =  free
//    __pic         =  no
//    __core        =  430X
//    __data_model  =  large
//    __code_model  =  large
//    Source file   =  
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\msp430f5529_timer.c
//    Command line  =  
//        -f C:\Users\颜子楠\AppData\Local\Temp\EWDEB0.tmp
//        (C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\msp430f5529_timer.c
//        -D NDEBUG -D RAM_VECTOR -lC
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Release\List
//        -lA
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Release\List
//        -o
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Release\Obj
//        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
//        -D__MSP430F5529__ -e --double=32 --dlib_config
//        D:\IAR\430\lib\dlib\dl430xllfn.h -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\ -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\inc\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\USB\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\USB\USB_config\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\USB\USB_User\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\srcUSB\USB_API\USB_CDC_API\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\USB\USB_API\USB_HID_API\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\USB\USB_API\USB_MSC_API\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\KEY\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\LED\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\12864\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\oled\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\mpu6050\inc\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\mpu6050\src\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\nokia5110\inc\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\nokia5110\src\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\LQ_1.8_TFT\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\LCD_API\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\2.2TFT\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\delay\
//        -I C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\System\ -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\System\inc\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\System\src\
//        -I C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\User\ -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\User\USER\ -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\UCOSII\CONFIG\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\uCOSII\App\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\uCOSII\CONFIHG\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\uCOSII\PORT\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\UCOSII\CORE\
//        -I C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\FatFs\
//        -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\FatFs\option\
//        -I C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\src\ -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\ -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\nrf24l01\
//        -I C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\MATH\ -I
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HAL\
//        --core=430X --data_model=large -Ol --multiplier=32
//        --hw_workaround=CPU40 --hw_workaround=nop_after_lpm -DNDEBUG
//        --code_model=large)
//    Locale        =  Chinese (Simplified)_CHN.936
//    List file     =  
//        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Release\List\msp430f5529_timer.s43
//
///////////////////////////////////////////////////////////////////////////////

        NAME msp430f5529_timer

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__code_model", "large"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "large"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?DivMod32u
        EXTERN __iar_HWMUL
        EXTERN _Cast32uto32f
        EXTERN _Mul32f
        EXTERN _Cast32fto32u
        EXTERN _Div32f
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC TIMERX
        PUBLIC TIMER_CHANEL_PIN
        PUBLIC TIMER_CLK_PIN
        PUBLIC TIMER_Capture_CalTime_Us
        PUBLIC TIMER_Capture_Clear
        PUBLIC TIMER_Capture_GetValue
        PUBLIC TIMER_Capture_Init
        PUBLIC TIMER_Capture_SetMode
        PUBLIC TIMER_ClearITPendingBit
        PUBLIC TIMER_Delay_Us
        PUBLIC TIMER_GetChannelCounterValue
        PUBLIC TIMER_GetChannelPinInValue
        PUBLIC TIMER_GetChannelPinOutValue
        PUBLIC TIMER_GetCounterValue
        PUBLIC TIMER_GetITStatus
        PUBLIC TIMER_ITConfig
        PUBLIC TIMER_Interval_Us
        PUBLIC TIMER_PRECISON
        PUBLIC TIMER_PWM_MultiChannel_Init
        PUBLIC TIMER_PWM_SetChannelDuty
        PUBLIC TIMER_PWM_SetChannelOutmod
        PUBLIC TIMER_PWM_SetFrequency
        PUBLIC TIMER_Pluse_Clear
        PUBLIC TIMER_Pluse_GetValue
        PUBLIC TIMER_Pluse_Init
        PUBLIC TIMER_Run
        PUBLIC TIMER_SetChannelCounterValue
        PUBLIC TIMER_SetCounterValue
        PUBLIC TIMER_Stop
        PUBLIC TIMER_Timer_GetTime_Us
        PUBLIC TIMER_Timer_Init
        PUBLIC TIMER_Timer_Start
        PUBLIC TIMER_Timer_Stop
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H SameValue
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H SameValue
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H SameValue
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H SameValue
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H SameValue
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H SameValue
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H SameValue
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H SameValue
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN g_sClock
        EXTERN GPIO_MultiBits_Init

// C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\msp430f5529_timer.c
//    1 #include "msp430f5529_timer.h"
//    2 #include "msp430f5529_clock.h"
//    3 #include "msp430f5529_gpio.h"
//    4 #include "msp430f5529_system.h"
//    5 #include "stdarg.h"
//    6 
//    7 //定义4个指针数组保存 TIMERX 的地址

        RSEG DATA20_C:CONST:SORT:NOROOT(1)
//    8 const TIMER_MemMapPtr TIMERX[TIMER_NUM] ={TIMER_A0_BASE_PTR,TIMER_A1_BASE_PTR,TIMER_A2_BASE_PTR,TIMER_B0_BASE_PTR};
TIMERX:
        DATA32
        DC32 340H, 380H, 400H, 3C0H
//    9 //定义数组保存占空比最大值

        RSEG DATA20_C:CONST:SORT:NOROOT(1)
//   10 const uint32_t TIMER_PRECISON[TIMER_NUM]={TIMER_PWM_A0_PRECISON,TIMER_PWM_A1_PRECISON,TIMER_PWM_A2_PRECISON,TIMER_PWM_B0_PRECISON};
TIMER_PRECISON:
        DATA32
        DC32 1000, 1000, 1000, 20000
//   11 //定义通道引脚

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
//   12 const GPIO_PIN TIMER_CHANEL_PIN[TIMER_NUM][TIMER_CH_NUM]=
TIMER_CHANEL_PIN:
        DATA8
        DC8 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 0, 0, 0, 0, 7, 1, 0, 1, 1, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 1, 3, 1, 4, 1, 5, 0, 0, 0, 0, 0, 0, 0, 0, 4, 6, 4, 7
        DC8 6, 4, 6, 5, 6, 6, 2, 5, 2, 6
//   13 {// CH0    CH1    CH2    CH3    CH4    CH5    CH6
//   14   {{P1,1},{P1,2},{P1,3},{P1,4},{P1,5}},                  //TIMER_A0
//   15   {{P1,7},{P2,0},{P2,1}},                                //TIMER_A1
//   16   {{P2,3},{P2,4},{P2,5}},                                //TIMER_A2
//   17   {{P5,6},{P5,7},{P7,4},{P7,5},{P7,6},{P3,5},{P3,6}}     //TIMER_B0
//   18 };//通道引脚

        RSEG DATA20_C:CONST:SORT:NOROOT(0)
//   19 const GPIO_PIN TIMER_CLK_PIN[TIMER_NUM] =
TIMER_CLK_PIN:
        DATA8
        DC8 0, 0, 0, 6, 1, 2, 6, 7
//   20 {
//   21   {P1,0},                                                //TIMER_A0
//   22   {P1,6},                                                //TIMER_A1
//   23   {P2,2},                                                //TIMER_A2
//   24   {P7,7}                                                 //TIMER_B0
//   25 };//外部时钟输入引脚
//   26 /*******************************************************************************
//   27 *  函数名称：TIMER_PWM_MultiChannel_Init(TIMERn timer, uint32_t fre, uint8_t ChannelNum,...)
//   28 *  功能说明：定时器PWM输出初始化(可以多个通道同时初始化)
//   29 *  参数说明：TIMERn timer       ：定时器模块
//   30              uint32_t fre         ：频率
//   31              uint8_t ChannelNum   ：要初始化的通道数
//   32              ...                ：初始化的通道
//   33 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//   34 *  使用例程：实例一：（使用函数初始化时需要输入初始化通道数，初始化通道数可以为0，如：TIMER_PWM_MultiChannel_Init(TIMER_A0, 1000, 0);）
//   35              TIMER_PWM_MultiChannel_Init(TIMER_A0, 1000, 3, TIMER_CH1, TIMER_CH2, TIMER_CH4);
//   36              //定时器TIMER_A0初始化输出PWM波，频率为1000Hz,初始化3个通道，分别是：TIMER_CH1,TIMER_CH2,TIMER_CH4
//   37              实例二：(使用宏定义初始化时不需要输入初始化通道数)
//   38              TIMER_PWM_Init(TIMER_B0,1000,TIMER_CH1,TIMER_CH2,TIMER_CH3,TIMER_CH4,TIMER_CH5,TIMER_CH6);
//   39              //定时器TIMER_B0初始化输出PWM波，频率为1000Hz,初始化6个通道：TIMER_CH1,TIMER_CH2,TIMER_CH3,TIMER_CH4,TIMER_CH5,TIMER_CH6
//   40 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//   41 STATUS TIMER_PWM_MultiChannel_Init(TIMERn timer, uint32_t fre, uint8_t ChannelNum,...)
TIMER_PWM_MultiChannel_Init:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function TIMER_PWM_MultiChannel_Init
//   42 {
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        SUBA    #0x4, SP
          CFI CFA SP+40
        MOV.B   R12, R11
        MOV.W   R14, R8
        MOV.W   R15, R9
        MOV.B   R13, R7
//   43 //#ifdef DELAY_TIMER
//   44 //  //ASSERT((timer != DELAY_TIMER),
//   45 //         "TIMER_PWM_MultiChannel_Init",
//   46 //         "定时器已经设置为默认延时功能，不能再作为其他功能使用");       //不允许这种情况下还宏定义该定时器作为延时所用的定时器，请在system.h里修改DELAY_TIMER宏定义
//   47 //#endif
//   48 //  //ASSERT((timer==TIMER_A0&&ChannelNum<=TIMER_CH4)
//   49 //       ||(timer==TIMER_A1&&ChannelNum<=TIMER_CH2)
//   50 //       ||(timer==TIMER_A2&&ChannelNum<=TIMER_CH2)
//   51 //       ||(timer==TIMER_B0&&ChannelNum<=TIMER_CH6),
//   52 //       "TIMER_PWM_MultiChannel_Init",
//   53 //       "定时器通道参数超出范围！"); //断言检测输入参数*/
//   54   
//   55   va_list ap;
//   56   va_start(ap,ChanelNum);
        MOVA    SP, R15
        ADDA    #0x28, R15
        MOVA    R15, 0(SP)
//   57   for(int i=0;i < ChannelNum;i++)           //根据初始化的通道数，逐一初始化通道
        MOV.W   #0x0, R6
        JMP     ??TIMER_PWM_MultiChannel_Init_1
//   58   {
//   59     TIMER_CHn ch = va_arg(ap, TIMER_CHn);  //读取要初始化的通道
//   60     if((ch == TIMER_CH0) || (ch >= TIMER_CH_NUM))   //判断通道值是否合理
//   61     {
//   62       return ERROR;                                 //不合理返回ERROR
//   63     }
//   64     //初始化端口
//   65     GPIO_Init(TIMER_CHANEL_PIN[timer][ch].Port,TIMER_CHANEL_PIN[timer][ch].Pin,GPO|SEL);
??TIMER_PWM_MultiChannel_Init_0:
        MOV.W   #0x102, R14
        MOV.W   #0x1, R13
        MOV.B   R10, R15
        ADDA    R15, R15
        MOV.B   R11, R12
        ADDA    R12, R12
        MOVA    R12, R4
        ADDA    R12, R12
        ADDA    R12, R4
        ADDA    R12, R12
        ADDA    R4, R12
        MOVA    R12, R4
        ADDA    R4, R15
        MOVX.B  TIMER_CHANEL_PIN + 1(R15), R15
        SUB.B   #0x1, R15
        JN      ??TIMER_PWM_MultiChannel_Init_3
        RPT     R15
        RLAX.W  R13
??TIMER_PWM_MultiChannel_Init_3:
        ADD.B   #0x1, R15
        MOV.B   R11, R15
        ADDA    R15, R15
        MOVA    R15, R4
        ADDA    R15, R15
        ADDA    R15, R4
        ADDA    R15, R15
        ADDA    R4, R15
        MOV.B   R10, R12
        ADDA    R12, R12
        MOVA    R12, R4
        ADDA    R4, R15
        MOVX.B  TIMER_CHANEL_PIN(R15), R12
          CFI FunCall GPIO_MultiBits_Init
        CALLA   #GPIO_MultiBits_Init
//   66     //初始化占空比及输出波形
//   67     TIMERX[timer]->CCR[ch] = 0u;
        MOV.B   R11, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R10, R14
        ADDA    R14, R14
        MOVA    R14, R13
        ADDA    R13, R15
        MOV.W   #0x0, 0x12(R15)
//   68     TIMERX[timer]->CCTL[ch].IE = RESET;               //关闭通道中断
        MOV.B   R11, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R10, R14
        ADDA    R14, R14
        MOVA    R14, R13
        ADDA    R13, R15
        BIC.W   #0x10, 0x2(R15)
//   69     TIMERX[timer]->CCTL[ch].OUTMOD = DEFAULT_PWM_OUTMOD;      //输出波形设置
        MOV.B   R11, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R10, R14
        ADDA    R14, R14
        MOVA    R14, R13
        ADDA    R13, R15
        BIS.W   #0xe0, 0x2(R15)
//   70     TIMERX[timer]->CCTL[ch].CAPMODE = RESET;          //比较模式
        MOV.B   R11, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R10, R10
        ADDA    R10, R10
        MOVA    R10, R14
        ADDA    R14, R15
        BIC.W   #0x100, 0x2(R15)
        ADD.W   #0x1, R6
??TIMER_PWM_MultiChannel_Init_1:
        MOV.B   R7, R7
        CMP.W   R7, R6
        JGE     ??TIMER_PWM_MultiChannel_Init_4
        ADDX.A  #0x2, 0(SP)
        MOVA    @SP, R15
        MOVX.B  0xffffe(R15), R10
        CMP.B   #0x0, R10
        JEQ     ??TIMER_PWM_MultiChannel_Init_5
        CMP.B   #0x7, R10
        JNC     ??TIMER_PWM_MultiChannel_Init_0
??TIMER_PWM_MultiChannel_Init_5:
        MOV.B   #0x0, R12
        JMP     ??TIMER_PWM_MultiChannel_Init_2
//   71   }
//   72   va_end(ap);
//   73   
//   74   return TIMER_PWM_SetFrequency(timer,fre);
??TIMER_PWM_MultiChannel_Init_4:
        MOV.W   R8, R14
        MOV.W   R9, R15
        MOV.B   R11, R12
          CFI FunCall TIMER_PWM_SetFrequency
        CALLA   #TIMER_PWM_SetFrequency
??TIMER_PWM_MultiChannel_Init_2:
        ADDA    #0x4, SP
          CFI CFA SP+36
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
//   75 }
          CFI EndBlock cfiBlock0
//   76 /*******************************************************************************
//   77 *  函数名称：TIMER_PWM_SetChannelOutmod(TIMERn timer,TIMER_CHn ch,TIMER_OUTMODn outmod)
//   78 *  功能说明：PWM输出波形设置
//   79 *  参数说明：TIMERn timer       ：定时器模块
//   80              TIMER_CHn ch       ：定时器通道
//   81              TIMER_PWM_OUTMODn outmod ：输出波形模式
//   82 *  函数返回：无
//   83 *  使用例程：TIMER_PWM_SetChannelOutmod(TIMER_A0,TIMER_CH1,TIMER_PWM_OUTMOD3);  //修改定时器A0的TIMER_CH1通道输出波形
//   84 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//   85 void TIMER_PWM_SetChannelOutmod(TIMERn timer,TIMER_CHn ch,TIMER_PWM_OUTMODn outmod)
TIMER_PWM_SetChannelOutmod:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function TIMER_PWM_SetChannelOutmod
          CFI NoCalls
//   86 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
//   87   TIMERX[timer]->CCTL[ch].OUTMOD = outmod;      //输出波形设置
        MOV.B   R14, R14
        RLAM.W  #0x4, R14
        RLAM.W  #0x1, R14
        AND.W   #0xe0, R14
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R13, R10
        ADDA    R10, R10
        MOVA    R10, R11
        ADDA    R11, R15
        MOV.W   0x2(R15), R15
        AND.W   #0xff1f, R15
        BIS.W   R14, R15
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R11
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R14
        ADDA    R14, R11
        MOV.W   R15, 0x2(R11)
//   88 }
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
//   89 /*******************************************************************************
//   90 *  函数名称：TIMER_PWM_SetFrequency(TIMERn timer,uint32_t fre)
//   91 *  功能说明：定时器PWM频率设置(注意这里没有更改各个通道的占空比，所以修改频率后占空比变了，需要从新设置占空比)
//   92 *  参数说明：TIMERn timer       ：定时器模块
//   93              uint32_t fre         ：频率
//   94 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//   95 *  使用例程：TIMER_PWM_SetFrequency(TIMER_B0,1000);       //将定时器B输出频率修改为1000Hz
//   96 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//   97 STATUS  TIMER_PWM_SetFrequency(TIMERn timer,uint32_t fre)
TIMER_PWM_SetFrequency:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function TIMER_PWM_SetFrequency
//   98 {
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOV.B   R12, R10
        MOV.W   R14, R8
        MOV.W   R15, R9
//   99   if(fre == 0u)
        MOV.W   R8, R15
        ADDA    R9, R15
        JNE     ??TIMER_PWM_SetFrequency_3
//  100   {
//  101     TIMERX[timer]->MC = TIMER_MC_STOP;              //暂停输出PWM波
        MOV.B   R10, R10
        RLAM.A  #0x2, R10
        MOVX.A  TIMERX(R10), R15
        AND.W   #0xffcf, 0(R15)
//  102     return SUCCESS;
        MOV.B   #0x1, R12
        JMP     ??TIMER_PWM_SetFrequency_2
//  103   }
//  104   
//  105   TIMERX[timer]->CLR = BIT_SET;
??TIMER_PWM_SetFrequency_3:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIS.W   #0x4, 0(R15)
//  106   TIMERX[timer]->SSEL = TIMER_SSEL_SMCLK;           //先选择时钟源为SMCLK
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x200, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  107   TIMERX[timer]->ID = 0u;                           //分频系数清零
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  108   //时钟大小
//  109   uint32_t Counter_Value = g_sClock.SMCLK.nHZ/fre;                 //计算计数值
        MOVX.W  &g_sClock + 12, R12
        MOVX.W  &g_sClock + 14, R13
        MOV.W   R8, R14
        MOV.W   R9, R15
          CFI FunCall ?DivMod32u
        CALLA   #?DivMod32u
        JMP     ??TIMER_PWM_SetFrequency_0
//  110   while(Counter_Value > 65536u)        //这里不是0xffff，因为后面会-1，所以是(0xffff+1)=65536
//  111   {  //分频一次
//  112      TIMERX[timer]->ID ++;          
//  113      Counter_Value >>= 1;          
//  114      
//  115      if((TIMERX[timer]->ID == 3u) && (Counter_Value > 65536))   //这个时候意味得选择更低频率的时钟了
//  116      {
//  117        if(TIMERX[timer]->SSEL == TIMER_SSEL_ACLK)   //如果时钟已经是最低的ACLK了，那么意味着设置的频率太低了，失败返回ERROR
//  118        {
//  119          return ERROR;
//  120        }
//  121        //更换为更低的ACLK，从新配置
//  122        TIMERX[timer]->SSEL = TIMER_SSEL_ACLK;
??TIMER_PWM_SetFrequency_1:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x100, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  123        TIMERX[timer]->ID = 0u;  
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  124        Counter_Value = g_sClock.ACLK.nHZ/fre; 
        MOVX.W  &g_sClock + 24, R12
        MOVX.W  &g_sClock + 26, R13
        MOV.W   R8, R14
        MOV.W   R9, R15
          CFI FunCall ?DivMod32u
        CALLA   #?DivMod32u
//  125        continue;  
??TIMER_PWM_SetFrequency_0:
        CMP.W   #0x1, R13
        JNC     ??TIMER_PWM_SetFrequency_4
        JNE     ??TIMER_PWM_SetFrequency_5
        CMP.W   #0x1, R12
        JNC     ??TIMER_PWM_SetFrequency_4
??TIMER_PWM_SetFrequency_5:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        PUSH.W  R14
          CFI CFA SP+22
        MOV.B   R15, 0(SP)
        POP.W   R14
          CFI CFA SP+20
        RPT     #0x6
        RRUX.B  R14
        MOV.B   R14, R14
        ADD.W   #0x1, R14
        RLAM.W  #0x4, R14
        RLAM.W  #0x2, R14
        AND.W   #0xc0, R14
        AND.W   #0xff3f, R15
        BIS.W   R14, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R11
        MOV.W   R15, 0(R11)
        RRUM.W  #0x1, R13
        RRC.W   R12
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R14
        AND.B   #0xc0, R14
        CMP.B   #0xc0, R14
        JNE     ??TIMER_PWM_SetFrequency_0
        CMP.W   #0x1, R13
        JNC     ??TIMER_PWM_SetFrequency_0
        JNE     ??TIMER_PWM_SetFrequency_6
        CMP.W   #0x1, R12
        JNC     ??TIMER_PWM_SetFrequency_0
??TIMER_PWM_SetFrequency_6:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R14
        SWPB    R14
        AND.W   #0xff, R14
        AND.W   #0x3, R14
        CMP.B   #0x1, R14
        JNE     ??TIMER_PWM_SetFrequency_1
        MOV.B   #0x0, R12
        JMP     ??TIMER_PWM_SetFrequency_2
//  126      } 
//  127   }
//  128   if(Counter_Value <= 1)//出现这种情况,说明频率不合适
??TIMER_PWM_SetFrequency_4:
        CMP.W   #0x0, R13
        JNC     ??TIMER_PWM_SetFrequency_7
        JNE     ??TIMER_PWM_SetFrequency_8
        CMP.W   #0x2, R12
        JC      ??TIMER_PWM_SetFrequency_8
//  129   {
//  130     return ERROR; 
??TIMER_PWM_SetFrequency_7:
        MOV.B   #0x0, R12
        JMP     ??TIMER_PWM_SetFrequency_2
//  131   }
//  132 
//  133   TIMERX[timer]->CCR[0] = (uint16_t)(Counter_Value - 1u);//为什么要减一？？因为TAR/TBR计数器从CCR0变化到0还有一个计数周期
??TIMER_PWM_SetFrequency_8:
        ADD.W   #0xffff, R12
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   R12, 0x12(R15)
//  134   TIMERX[timer]->IE = RESET;                      //关闭中断
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x2, 0(R15)
//  135   TIMERX[timer]->MC = TIMER_MC_UP;                //增计数模式
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xffcf, R15
        BIS.W   #0x10, R15
        MOV.B   R10, R10
        RLAM.A  #0x2, R10
        MOVX.A  TIMERX(R10), R11
        MOV.W   R15, 0(R11)
//  136   
//  137   return SUCCESS;
        MOV.B   #0x1, R12
??TIMER_PWM_SetFrequency_2:
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
//  138 }
          CFI EndBlock cfiBlock2
//  139 /*******************************************************************************
//  140 *  函数名称：TIMER_PWM_SetChannelDuty(TIMERn timer,TIMER_CHn ch,uint32_t duty)
//  141 *  功能说明：PWM输出占空比设置
//  142 *  参数说明：TIMERn timer       ：定时器模块
//  143              TIMER_CHn ch       ：定时器通道
//  144              uint32_t duty      ：占空比
//  145 *  函数返回：无
//  146 *  使用例程：TIMER_PWM_SetChannelDuty(TIMER_A0,TIMER_CH1,800);  //修改定时器A0的TIMER_CH1通道占空比为(800/TIMAR_A0_PRECISON)*100%
//  147 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  148 void  TIMER_PWM_SetChannelDuty(TIMERn timer,TIMER_CHn ch,uint32_t duty)
TIMER_PWM_SetChannelDuty:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function TIMER_PWM_SetChannelDuty
//  149 {
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOV.B   R12, R10
        MOV.B   R13, R11
        MOV.W   R14, R12
        MOV.W   R15, R13
//  150   //ASSERT((timer==TIMER_A0&&ch<=TIMER_CH4)
//  151 //       ||(timer==TIMER_A1&&ch<=TIMER_CH2)
//  152 //       ||(timer==TIMER_A2&&ch<=TIMER_CH2)
//  153 //       ||(timer==TIMER_B0&&ch<=TIMER_CH6),
//  154 //       "TIMER_PWM_SetChannelDuty",
//  155 //       "定时器通道参数超出范围！"); //断言检测输入参数
//  156   
//  157   //ASSERT(duty <= TIMER_PRECISON[timer],
//  158 //         "TIMER_PWM_SetChannelDuty",
//  159 //         "定时器占空比参数超出范围！");      //用断言检测 占空比是否合理
//  160   
//  161   TIMERX[timer]->CCR[ch] = (uint16_t)((duty * (TIMERX[timer]->CCR[0]+1))/TIMER_PRECISON[timer]);
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.W  TIMER_PRECISON(R15), R14
        MOVX.W  TIMER_PRECISON + 2(R15), R15
        MOV.B   R10, R8
        RLAM.A  #0x2, R8
        MOVX.A  TIMERX(R8), R8
        MOV.W   0x12(R8), R8
        ADD.W   #0x1, R8
        PUSH.W  SR
          CFI CFA SP+22
        DINT
        NOP
        MOV.W   R8, &__iar_HWMUL + 16          // MPY32L
        MOV.W   R12, &__iar_HWMUL + 32         // OP2L
        MOV.W   R13, &__iar_HWMUL + 34         // OP2H
        MOV.W   &__iar_HWMUL + 36, R12         // RES0
        MOV.W   &__iar_HWMUL + 38, R13         // RES1
        NOP
        POP.W   SR
          CFI CFA SP+20
          CFI FunCall ?DivMod32u
        CALLA   #?DivMod32u
        MOV.B   R10, R10
        RLAM.A  #0x2, R10
        MOVX.A  TIMERX(R10), R15
        MOV.B   R11, R11
        ADDA    R11, R11
        MOVA    R11, R14
        ADDA    R14, R15
        MOV.W   R12, 0x12(R15)
//  162 }
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock3
//  163 /*******************************************************************************
//  164 *  函数名称：TIMER_Interval_Us(TIMERn timer,uint32_t us)
//  165 *  功能说明：定时器定时初始化(单位：us)
//  166 *  参数说明：TIMERn timer       ：定时器模块
//  167              uint32_t us          : 定时时间
//  168 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//  169 *  使用例程：TIMER_Interval_Us(TIMER_B0,2500);  //TB定时间隔2.5ms中断
//  170 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  171 STATUS  TIMER_Interval_Us(TIMERn timer,uint32_t us)
TIMER_Interval_Us:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function TIMER_Interval_Us
//  172 {
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOV.B   R12, R10
        MOV.W   R14, R8
        MOV.W   R15, R9
//  173 #ifdef DELAY_TIMER
//  174   //ASSERT((timer != DELAY_TIMER),
//  175          "TIMER_Interval_Us",
//  176          "定时器已经设置为默认延时功能，不能再作为其他功能使用");       //不允许这种情况下还宏定义该定时器作为延时所用的定时器，请在system.h里修改DELAY_TIMER宏定义
//  177 #endif
//  178   TIMERX[timer]->CLR = BIT_SET;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIS.W   #0x4, 0(R15)
//  179   TIMERX[timer]->SSEL = TIMER_SSEL_SMCLK;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x200, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  180   TIMERX[timer]->ID = 0u;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  181   //计数值
//  182   uint32_t Counter_Value = (uint32_t)(us * g_sClock.SMCLK.fMHZ);
        MOV.W   R8, R12
        MOV.W   R9, R13
          CFI FunCall _Cast32uto32f
        CALLA   #_Cast32uto32f
        MOV.W   R12, R14
        MOV.W   R13, R15
        MOVX.W  &g_sClock + 20, R12
        MOVX.W  &g_sClock + 22, R13
          CFI FunCall _Mul32f
        CALLA   #_Mul32f
          CFI FunCall _Cast32fto32u
        CALLA   #_Cast32fto32u
        JMP     ??TIMER_Interval_Us_0
//  183   while(Counter_Value > 65536)
//  184   {
//  185      TIMERX[timer]->ID ++; 
//  186      Counter_Value >>= 1;  
//  187      if((TIMERX[timer]->ID == 3u) && (Counter_Value > 65536))   //这个时候意味得选择更低频率的时钟了
//  188      {
//  189       if(TIMERX[timer]->SSEL == TIMER_SSEL_ACLK) //如果时钟已经是最低的ACLK了，那么意味着设置的频率太低了，失败返回ERROR
//  190       {
//  191         return ERROR;
//  192       }
//  193       //更换为更低的ACLK，从新配置
//  194       TIMERX[timer]->SSEL = TIMER_SSEL_ACLK;
??TIMER_Interval_Us_1:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x100, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  195       TIMERX[timer]->ID = 0u;  
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  196       Counter_Value = (uint32_t)(us * g_sClock.ACLK.fMHZ);
        MOV.W   R8, R12
        MOV.W   R9, R13
          CFI FunCall _Cast32uto32f
        CALLA   #_Cast32uto32f
        MOV.W   R12, R14
        MOV.W   R13, R15
        MOVX.W  &g_sClock + 32, R12
        MOVX.W  &g_sClock + 34, R13
          CFI FunCall _Mul32f
        CALLA   #_Mul32f
          CFI FunCall _Cast32fto32u
        CALLA   #_Cast32fto32u
//  197       continue;  
??TIMER_Interval_Us_0:
        CMP.W   #0x1, R13
        JNC     ??TIMER_Interval_Us_3
        JNE     ??TIMER_Interval_Us_4
        CMP.W   #0x1, R12
        JNC     ??TIMER_Interval_Us_3
??TIMER_Interval_Us_4:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        PUSH.W  R14
          CFI CFA SP+22
        MOV.B   R15, 0(SP)
        POP.W   R14
          CFI CFA SP+20
        RPT     #0x6
        RRUX.B  R14
        MOV.B   R14, R14
        ADD.W   #0x1, R14
        RLAM.W  #0x4, R14
        RLAM.W  #0x2, R14
        AND.W   #0xc0, R14
        AND.W   #0xff3f, R15
        BIS.W   R14, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R11
        MOV.W   R15, 0(R11)
        RRUM.W  #0x1, R13
        RRC.W   R12
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R14
        AND.B   #0xc0, R14
        CMP.B   #0xc0, R14
        JNE     ??TIMER_Interval_Us_0
        CMP.W   #0x1, R13
        JNC     ??TIMER_Interval_Us_0
        JNE     ??TIMER_Interval_Us_5
        CMP.W   #0x1, R12
        JNC     ??TIMER_Interval_Us_0
??TIMER_Interval_Us_5:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R14
        SWPB    R14
        AND.W   #0xff, R14
        AND.W   #0x3, R14
        CMP.B   #0x1, R14
        JNE     ??TIMER_Interval_Us_1
        MOV.B   #0x0, R12
        JMP     ??TIMER_Interval_Us_2
//  198      } 
//  199   }
//  200   if(Counter_Value <= 1)//出现这种情况,说明频率不合适
??TIMER_Interval_Us_3:
        CMP.W   #0x0, R13
        JNC     ??TIMER_Interval_Us_6
        JNE     ??TIMER_Interval_Us_7
        CMP.W   #0x2, R12
        JC      ??TIMER_Interval_Us_7
//  201   {
//  202     return ERROR; 
??TIMER_Interval_Us_6:
        MOV.B   #0x0, R12
        JMP     ??TIMER_Interval_Us_2
//  203   }
//  204   
//  205   TIMERX[timer]->CCR[0] = (uint16_t)(Counter_Value - 1u);//为什么要减一？？因为TAR/TBR计数器从CCR0变化到0还有一个计数周期
??TIMER_Interval_Us_7:
        ADD.W   #0xffff, R12
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   R12, 0x12(R15)
//  206   TIMERX[timer]->CCTL[0].CAPMODE = RESET;          //比较模式
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x100, 0x2(R15)
//  207   TIMERX[timer]->IE = RESET;             //关闭溢出中断
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x2, 0(R15)
//  208   TIMERX[timer]->CCTL[0].IE = RESET;     //关闭通道中断
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x10, 0x2(R15)
//  209   TIMERX[timer]->MC = TIMER_MC_UP;      //增计数模式
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xffcf, R15
        BIS.W   #0x10, R15
        MOV.B   R10, R10
        RLAM.A  #0x2, R10
        MOVX.A  TIMERX(R10), R11
        MOV.W   R15, 0(R11)
//  210   
//  211   return SUCCESS;
        MOV.B   #0x1, R12
??TIMER_Interval_Us_2:
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
//  212 }
          CFI EndBlock cfiBlock4
//  213 /*******************************************************************************
//  214 *  函数名称：TIMER_Delay_Us(TIMERn timer,uint32_t us)
//  215 *  功能说明：定时器延时（单位：ms）
//  216 *  参数说明：TIMERn timer       ：定时器模块
//  217              uint32_t us          : 定时时间
//  218 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//  219 *  使用例程：TIMER_Delay_Us(TIMER_B0 ,5000);      //在此处延时5ms
//  220 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  221 STATUS TIMER_Delay_Us(TIMERn timer,uint32_t us)
TIMER_Delay_Us:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function TIMER_Delay_Us
//  222 {
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOV.B   R12, R10
        MOV.W   R14, R8
        MOV.W   R15, R9
//  223   TIMERX[timer]->CLR = BIT_SET;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIS.W   #0x4, 0(R15)
//  224   TIMERX[timer]->SSEL = TIMER_SSEL_SMCLK;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x200, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  225   TIMERX[timer]->ID = 0u;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  226   //计数值
//  227   uint32_t Counter_Value = (uint32_t)(us * g_sClock.SMCLK.fMHZ);
        MOV.W   R8, R12
        MOV.W   R9, R13
          CFI FunCall _Cast32uto32f
        CALLA   #_Cast32uto32f
        MOV.W   R12, R14
        MOV.W   R13, R15
        MOVX.W  &g_sClock + 20, R12
        MOVX.W  &g_sClock + 22, R13
          CFI FunCall _Mul32f
        CALLA   #_Mul32f
          CFI FunCall _Cast32fto32u
        CALLA   #_Cast32fto32u
        JMP     ??TIMER_Delay_Us_0
//  228   while(Counter_Value > 65536)
//  229   {
//  230      TIMERX[timer]->ID ++; 
//  231      Counter_Value >>= 1;  
//  232      if((TIMERX[timer]->ID == 3u) && (Counter_Value > 65536))   //这个时候意味得选择更低频率的时钟了
//  233      {
//  234       if(TIMERX[timer]->SSEL == TIMER_SSEL_ACLK) //如果时钟已经是最低的ACLK了，那么意味着设置的频率太低了，失败返回ERROR
//  235       {
//  236         return ERROR;
//  237       }
//  238       //更换为更低的ACLK，从新配置
//  239       TIMERX[timer]->SSEL = TIMER_SSEL_ACLK;
??TIMER_Delay_Us_1:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x100, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  240       TIMERX[timer]->ID = 0u;  
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  241       Counter_Value = (uint32_t)(us * g_sClock.ACLK.fMHZ);
        MOV.W   R8, R12
        MOV.W   R9, R13
          CFI FunCall _Cast32uto32f
        CALLA   #_Cast32uto32f
        MOV.W   R12, R14
        MOV.W   R13, R15
        MOVX.W  &g_sClock + 32, R12
        MOVX.W  &g_sClock + 34, R13
          CFI FunCall _Mul32f
        CALLA   #_Mul32f
          CFI FunCall _Cast32fto32u
        CALLA   #_Cast32fto32u
//  242       continue;  
??TIMER_Delay_Us_0:
        CMP.W   #0x1, R13
        JNC     ??TIMER_Delay_Us_4
        JNE     ??TIMER_Delay_Us_5
        CMP.W   #0x1, R12
        JNC     ??TIMER_Delay_Us_4
??TIMER_Delay_Us_5:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        PUSH.W  R14
          CFI CFA SP+22
        MOV.B   R15, 0(SP)
        POP.W   R14
          CFI CFA SP+20
        RPT     #0x6
        RRUX.B  R14
        MOV.B   R14, R14
        ADD.W   #0x1, R14
        RLAM.W  #0x4, R14
        RLAM.W  #0x2, R14
        AND.W   #0xc0, R14
        AND.W   #0xff3f, R15
        BIS.W   R14, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R11
        MOV.W   R15, 0(R11)
        RRUM.W  #0x1, R13
        RRC.W   R12
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R14
        AND.B   #0xc0, R14
        CMP.B   #0xc0, R14
        JNE     ??TIMER_Delay_Us_0
        CMP.W   #0x1, R13
        JNC     ??TIMER_Delay_Us_0
        JNE     ??TIMER_Delay_Us_6
        CMP.W   #0x1, R12
        JNC     ??TIMER_Delay_Us_0
??TIMER_Delay_Us_6:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R14
        SWPB    R14
        AND.W   #0xff, R14
        AND.W   #0x3, R14
        CMP.B   #0x1, R14
        JNE     ??TIMER_Delay_Us_1
        MOV.B   #0x0, R12
        JMP     ??TIMER_Delay_Us_3
//  243      } 
//  244   }
//  245   if(Counter_Value <= 1)//出现这种情况,说明频率不合适
??TIMER_Delay_Us_4:
        CMP.W   #0x0, R13
        JNC     ??TIMER_Delay_Us_7
        JNE     ??TIMER_Delay_Us_8
        CMP.W   #0x2, R12
        JC      ??TIMER_Delay_Us_8
//  246   {
//  247     return ERROR; 
??TIMER_Delay_Us_7:
        MOV.B   #0x0, R12
        JMP     ??TIMER_Delay_Us_3
//  248   }
//  249   
//  250   TIMERX[timer]->CCR[0] = (uint16_t)(Counter_Value - 1u);//为什么要减一？？因为TAR/TBR计数器从CCR0变化到0还有一个计数周期
??TIMER_Delay_Us_8:
        ADD.W   #0xffff, R12
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   R12, 0x12(R15)
//  251   TIMERX[timer]->CCTL[0].CAPMODE = RESET;          //比较模式
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x100, 0x2(R15)
//  252   TIMERX[timer]->IE = RESET;             //关闭溢出中断
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x2, 0(R15)
//  253   TIMERX[timer]->CCTL[0].IE = RESET;     //关闭通道中断
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x10, 0x2(R15)
//  254   TIMERX[timer]->MC = TIMER_MC_UP;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xffcf, R15
        BIS.W   #0x10, R15
        MOV.B   R10, R11
        RLAM.A  #0x2, R11
        MOVX.A  TIMERX(R11), R11
        MOV.W   R15, 0(R11)
//  255   
//  256   TIMERX[timer]->CCTL[0].CTL = 0;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   #0x0, 0x2(R15)
//  257   TIMERX[timer]->IFG = RESET;
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIC.W   #0x1, 0(R15)
//  258   while(TIMERX[timer]->IFG == RESET);
??TIMER_Delay_Us_2:
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIT.W   #0x1, 0(R15)
        JNC     ??TIMER_Delay_Us_2
//  259   TIMERX[timer]->CTL = 0;
        MOV.B   R10, R10
        RLAM.A  #0x2, R10
        MOVX.A  TIMERX(R10), R15
        MOV.W   #0x0, 0(R15)
//  260   
//  261   return SUCCESS;
        MOV.B   #0x1, R12
??TIMER_Delay_Us_3:
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
//  262 }
          CFI EndBlock cfiBlock5
//  263 /*******************************************************************************
//  264 *  函数名称：TIMER_Pluse_Init    (TIMERn timer)
//  265 *  功能说明：定时器脉冲计数初始化
//  266 *  参数说明：TIMERn timer       ：定时器模块
//  267 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//  268 *  使用例程：TIMER_Pluse_Init    (TIMER_A1);    //定时器TA1初始化为脉冲计数功能
//  269 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  270 STATUS  TIMER_Pluse_Init    (TIMERn timer)
TIMER_Pluse_Init:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function TIMER_Pluse_Init
//  271 { 
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
        MOV.B   R12, R10
//  272 #ifdef DELAY_TIMER
//  273   //ASSERT((timer != DELAY_TIMER),
//  274          "TIMER_Pluse_Init",
//  275          "定时器已经设置为默认延时功能，不能再作为其他功能使用");       //不允许这种情况下还宏定义该定时器作为延时所用的定时器，请在system.h里修改DELAY_TIMER宏定义
//  276 #endif 
//  277   //端口设置为输入方向//选择第二功能
//  278   GPIO_Init(TIMER_CLK_PIN[timer].Port,TIMER_CLK_PIN[timer].Pin,GPI|SEL);
        MOV.W   #0x101, R14
        MOV.W   #0x1, R13
        MOV.B   R10, R15
        ADDA    R15, R15
        MOVX.B  TIMER_CLK_PIN + 1(R15), R15
        SUB.B   #0x1, R15
        JN      ??TIMER_Pluse_Init_0
        RPT     R15
        RLAX.W  R13
??TIMER_Pluse_Init_0:
        ADD.B   #0x1, R15
        MOV.B   R10, R15
        ADDA    R15, R15
        MOVX.B  TIMER_CLK_PIN(R15), R12
          CFI FunCall GPIO_MultiBits_Init
        CALLA   #GPIO_MultiBits_Init
//  279   
//  280   TIMERX[timer]->CLR = BIT_SET;                       
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIS.W   #0x4, 0(R15)
//  281   TIMERX[timer]->SSEL = TIMER_SSEL_INCLK;             //时钟源选择为外部输入
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIS.W   #0x300, 0(R15)
//  282   TIMERX[timer]->ID = 0u;                             //不分频
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  283   TIMERX[timer]->MC = TIMER_MC_CONTINOUS;             //连续计数模式
        MOV.B   R10, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xffcf, R15
        BIS.W   #0x20, R15
        MOV.B   R10, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  284   TIMERX[timer]->IE = RESET;                          //禁止溢出中断
        MOV.B   R10, R10
        RLAM.A  #0x2, R10
        MOVX.A  TIMERX(R10), R15
        BIC.W   #0x2, 0(R15)
//  285   
//  286   return SUCCESS;
        MOV.B   #0x1, R12
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
//  287 }
          CFI EndBlock cfiBlock6
//  288 /*******************************************************************************
//  289 *  函数名称：TIMER_Pluse_GetValue(TIMERn timer,uint16_t overflowTime)
//  290 *  功能说明：定时器脉冲计数值获取
//  291 *  参数说明：TIMERn timer       ：定时器模块
//  292              uint16_t overflowTime ：计数器溢出次数
//  293 *  函数返回：定时器脉冲计数值
//  294 *  使用例程：
//  295              int32 pulse = TIMER_Pluse_GetValue(TIMER_A1,0);    //在没有发生溢出的情况下读取脉冲个数
//  296              TIMER_Pluse_Clear   (TIMER_A1);                    //读取后应该要清零
//  297 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  298 uint32_t TIMER_Pluse_GetValue(TIMERn timer,uint16_t overflowTime)
TIMER_Pluse_GetValue:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function TIMER_Pluse_GetValue
          CFI NoCalls
//  299 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
//  300   return (TIMERX[timer]->R + (overflowTime*65536u));
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.W   0x10(R15), R14
        MOV.W   #0x0, R15
        MOV.W   R13, R12
        MOV.W   #0x0, R13
        MOV.W   R12, R13
        MOV.W   #0x0, R12
        ADD.W   R12, R14
        ADDC.W  R13, R15
        MOV.W   R14, R12
        MOV.W   R15, R13
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
//  301 }
          CFI EndBlock cfiBlock7
//  302 /*******************************************************************************
//  303 *  函数名称：TIMER_Pluse_Clear   (TIMERn timer)
//  304 *  功能说明：定时器脉冲计数值清零
//  305 *  参数说明：TIMERn timer       ：定时器模块
//  306 *  函数返回：无
//  307 *  使用例程：
//  308              int32 pulse = TIMER_Pluse_Read    (TIMER_A1,0);    //在没有发生溢出的情况下读取脉冲个数
//  309              TIMER_Pluse_Clear   (TIMER_A1);                    //读取后应该要清零
//  310 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  311 void   TIMER_Pluse_Clear   (TIMERn timer)
TIMER_Pluse_Clear:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function TIMER_Pluse_Clear
          CFI NoCalls
//  312 {
//  313   TIMERX[timer]->R = 0;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.W   #0x0, 0x10(R15)
//  314 }
        RETA
          CFI EndBlock cfiBlock8
//  315 /*******************************************************************************
//  316 *  函数名称：TIMER_Capture_Init(TIMERn timer,TIMER_CHn ch,TIMER_CAPTUREn capmode)
//  317 *  功能说明：定时器捕获初始化
//  318 *  参数说明：TIMERn timer        ：定时器模块
//  319              TIMER_CHn ch        ：定时器通道
//  320              TIMER_CAPTUREn capmode：捕获模式
//  321 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//  322 *  使用例程：TIMER_Capture_Init(TIMER_A0,TIMER_CH1,CAP_Rising);         //定时器TA0 CCR1通道初始化为边缘捕获，上升沿捕获
//  323 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  324 STATUS TIMER_Capture_Init(TIMERn timer,TIMER_CHn ch,TIMER_CAPTUREn capmode)
TIMER_Capture_Init:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function TIMER_Capture_Init
//  325 {
        PUSHM.A #0x4, R11
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+20
        MOV.B   R13, R15
//  326 //#ifdef DELAY_TIMER
//  327 //  //ASSERT((timer != DELAY_TIMER),
//  328 //         "TIMER_Capture_Init",
//  329 //         "定时器已经设置为默认延时功能，不能再作为其他功能使用");       //不允许这种情况下还宏定义该定时器作为延时所用的定时器，请在system.h里修改DELAY_TIMER宏定义
//  330 //#endif
//  331 //  //ASSERT((timer==TIMER_A0&&ch<=TIMER_CH4)
//  332 //       ||(timer==TIMER_A1&&ch<=TIMER_CH2)
//  333 //       ||(timer==TIMER_A2&&ch<=TIMER_CH2)
//  334 //       ||(timer==TIMER_B0&&ch<=TIMER_CH6),
//  335 //       "TIMER_Capture_Init",
//  336 //       "定时器通道参数超出范围！"); //断言检测输入参数
//  337  
//  338   TIMERX[timer]->CCTL[ch].CAPMODE = BIT_SET;                //设为捕获模式
        MOV.B   R12, R13
        RLAM.A  #0x2, R13
        MOVX.A  TIMERX(R13), R13
        MOV.B   R15, R10
        ADDA    R10, R10
        MOVA    R10, R11
        ADDA    R11, R13
        BIS.W   #0x100, 0x2(R13)
//  339   TIMERX[timer]->CCTL[ch].CM = capmode;                 //选择捕获沿
        MOV.B   R14, R14
        RPT     #0x6
        RLAX.B  R14
        AND.W   #0xff, R14
        SWPB    R14
        MOV.B   R12, R11
        RLAM.A  #0x2, R11
        MOVX.A  TIMERX(R11), R11
        MOV.B   R15, R13
        ADDA    R13, R13
        MOVA    R13, R10
        ADDA    R10, R11
        MOV.W   0x2(R11), R11
        AND.W   #0x3fff, R11
        BIS.W   R14, R11
        MOV.B   R12, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.B   R15, R13
        ADDA    R13, R13
        MOVA    R13, R10
        ADDA    R10, R14
        MOV.W   R11, 0x2(R14)
//  340   
//  341   TIMERX[timer]->CCTL[ch].CCIS = (timer == TIMER_B0) ? TIMER_CCIS_1 : TIMER_CCIS_0;
        CMP.B   #0x3, R12
        JNE     ??TIMER_Capture_Init_1
        MOV.W   #0x1, R14
        JMP     ??TIMER_Capture_Init_0
??TIMER_Capture_Init_1:
        MOV.W   #0x0, R14
??TIMER_Capture_Init_0:
        RPT     #0x4
        RLAX.B  R14
        AND.W   #0xff, R14
        SWPB    R14
        AND.W   #0x3000, R14
        MOV.B   R12, R11
        RLAM.A  #0x2, R11
        MOVX.A  TIMERX(R11), R11
        MOV.B   R15, R13
        ADDA    R13, R13
        MOVA    R13, R10
        ADDA    R10, R11
        MOV.W   0x2(R11), R11
        AND.W   #0xcfff, R11
        BIS.W   R14, R11
        MOV.B   R12, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.B   R15, R13
        ADDA    R13, R13
        MOVA    R13, R10
        ADDA    R10, R14
        MOV.W   R11, 0x2(R14)
//  342   
//  343   TIMERX[timer]->CLR = BIT_SET;
        MOV.B   R12, R11
        RLAM.A  #0x2, R11
        MOVX.A  TIMERX(R11), R11
        BIS.W   #0x4, 0(R11)
//  344   TIMERX[timer]->SSEL = TIMER_SSEL_SMCLK;
        MOV.B   R12, R11
        RLAM.A  #0x2, R11
        MOVX.A  TIMERX(R11), R11
        MOV.W   @R11, R11
        AND.W   #0xfcff, R11
        BIS.W   #0x200, R11
        MOV.B   R12, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R11, 0(R14)
//  345   TIMERX[timer]->ID = 0u; //这里选择子系统时钟，除非频率特别低时才使用辅助时钟
        MOV.B   R12, R11
        RLAM.A  #0x2, R11
        MOVX.A  TIMERX(R11), R11
        AND.W   #0xff3f, 0(R11)
//  346   TIMERX[timer]->IE = RESET;              //关闭溢出中断
        MOV.B   R12, R11
        RLAM.A  #0x2, R11
        MOVX.A  TIMERX(R11), R11
        BIC.W   #0x2, 0(R11)
//  347   TIMERX[timer]->CCTL[ch].IE = RESET;     //关闭通道中断
        MOV.B   R12, R11
        RLAM.A  #0x2, R11
        MOVX.A  TIMERX(R11), R11
        MOV.B   R15, R14
        ADDA    R14, R14
        MOVA    R14, R13
        ADDA    R13, R11
        BIC.W   #0x10, 0x2(R11)
//  348   TIMERX[timer]->MC = TIMER_MC_CONTINOUS;             //连续计数模式
        MOV.B   R12, R11
        RLAM.A  #0x2, R11
        MOVX.A  TIMERX(R11), R11
        MOV.W   @R11, R11
        AND.W   #0xffcf, R11
        BIS.W   #0x20, R11
        MOV.B   R12, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R11, 0(R14)
//  349   
//  350   //端口设置为输入方,选择第二功能
//  351   GPIO_Init(TIMER_CHANEL_PIN[timer][ch].Port,TIMER_CHANEL_PIN[timer][ch].Pin,GPI|SEL);
        MOV.W   #0x101, R14
        MOV.W   #0x1, R13
        MOV.B   R15, R11
        ADDA    R11, R11
        MOV.B   R12, R10
        ADDA    R10, R10
        MOVA    R10, R8
        ADDA    R10, R10
        ADDA    R10, R8
        ADDA    R10, R10
        ADDA    R8, R10
        MOVA    R10, R8
        ADDA    R8, R11
        MOVX.B  TIMER_CHANEL_PIN + 1(R11), R10
        SUB.B   #0x1, R10
        JN      ??TIMER_Capture_Init_2
        RPT     R10
        RLAX.W  R13
??TIMER_Capture_Init_2:
        ADD.B   #0x1, R10
        MOV.B   R12, R12
        ADDA    R12, R12
        MOVA    R12, R11
        ADDA    R12, R12
        ADDA    R12, R11
        ADDA    R12, R12
        ADDA    R11, R12
        MOV.B   R15, R15
        ADDA    R15, R15
        MOVA    R15, R11
        ADDA    R11, R12
        MOVX.B  TIMER_CHANEL_PIN(R12), R12
          CFI FunCall GPIO_MultiBits_Init
        CALLA   #GPIO_MultiBits_Init
//  352   
//  353   return SUCCESS;
        MOV.B   #0x1, R12
        POPM.A  #0x4, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
//  354 }
          CFI EndBlock cfiBlock9
//  355 /*******************************************************************************
//  356 *  函数名称：TIMER_Capture_SetMode(TIMERn timer, TIMER_CHn ch, TIMER_CAPTUREn cap_mode)
//  357 *  功能说明：定时器捕获边沿设置
//  358 *  参数说明：TIMERn timer        ：定时器模块
//  359              TIMER_CHn ch        ：定时器通道
//  360              TIMER_CAPTUREn capmode：捕获模式
//  361 *  函数返回：无
//  362 *  使用例程：TIMER_Capture_SetMode(TIMER_A0,TIMER_CH1,CAP_Rising);         //定时器TA0 CCR1通道初始化为边缘捕获，上升沿捕获
//  363 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  364 void   TIMER_Capture_SetMode   (TIMERn timer, TIMER_CHn ch, TIMER_CAPTUREn cap_mode)
TIMER_Capture_SetMode:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function TIMER_Capture_SetMode
          CFI NoCalls
//  365 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
//  366    TIMERX[timer]->CCTL[ch].CM = cap_mode;                 //设置捕获沿
        MOV.B   R14, R14
        RPT     #0x6
        RLAX.B  R14
        AND.W   #0xff, R14
        SWPB    R14
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R13, R10
        ADDA    R10, R10
        MOVA    R10, R11
        ADDA    R11, R15
        MOV.W   0x2(R15), R15
        AND.W   #0x3fff, R15
        BIS.W   R14, R15
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R11
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R14
        ADDA    R14, R11
        MOV.W   R15, 0x2(R11)
//  367 }
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock10
//  368 /*******************************************************************************
//  369 *  函数名称：TIMER_Capture_Clear     (TIMERn timer,TIMER_CHn ch)
//  370 *  功能说明：某一通道读取数据清零
//  371 *  参数说明：TIMERn timer       ：定时器模块
//  372              TIMER_CHn ch       ：定时器通道
//  373 *  函数返回：
//  374 *  使用例程：int16 overflowTime;  //定义变量，在定时器溢出中断里对该值增一
//  375              ......
//  376              data=TIMER_Capture_GetTime_Us(TIMER_A0,TIMER_CH1,overflowTime)
//  377              TIMER_Capture_Clear(TIMER_A0,TIMER_CH1);  //清零
//  378              overflowTime=0;       //清零
//  379 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  380 void   TIMER_Capture_Clear     (TIMERn timer,TIMER_CHn ch)
TIMER_Capture_Clear:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function TIMER_Capture_Clear
          CFI NoCalls
//  381 {
//  382 //  //ASSERT((timer==TIMER_A0&&ch<=TIMER_CH4)
//  383 //       ||(timer==TIMER_A1&&ch<=TIMER_CH2)
//  384 //       ||(timer==TIMER_A2&&ch<=TIMER_CH2)
//  385 //       ||(timer==TIMER_B0&&ch<=TIMER_CH6),
//  386 //       "TIMER_Capture_Clear",
//  387 //       "定时器通道参数超出范围！"); //断言检测输入参数
//  388   
//  389   TIMERX[timer]->CCR[ch] = 0u;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R14
        ADDA    R14, R15
        MOV.W   #0x0, 0x12(R15)
//  390   TIMERX[timer]->R = 0u;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.W   #0x0, 0x10(R15)
//  391 }
        RETA
          CFI EndBlock cfiBlock11
//  392 /*******************************************************************************
//  393 *  函数名称：TIMER_Capture_GetValue(TIMERn timer,TIMER_CHn ch)
//  394 *  功能说明：读取发生捕获时定时器该通道计数值
//  395 *  参数说明：TIMERn timer       ：定时器模块
//  396              TIMER_CHn ch       ：定时器通道
//  397 *  函数返回：
//  398 *  使用例程：
//  399              uint16_t value = TIMER_Capture_GetValue(TIMER_A0,TIMER_CH1);  //读取发生捕获时的时间
//  400 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  401 uint16_t TIMER_Capture_GetValue(TIMERn timer,TIMER_CHn ch)
TIMER_Capture_GetValue:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function TIMER_Capture_GetValue
          CFI NoCalls
//  402 {
//  403   //ASSERT((timer==TIMER_A0&&ch<=TIMER_CH4)
//  404 //       ||(timer==TIMER_A1&&ch<=TIMER_CH2)
//  405 //       ||(timer==TIMER_A2&&ch<=TIMER_CH2)
//  406 //       ||(timer==TIMER_B0&&ch<=TIMER_CH6),
//  407 //       "TIMER_Capture_GetValue",
//  408 //       "定时器通道参数超出范围！"); //断言检测输入参数
//  409   
//  410   return TIMERX[timer]->CCR[ch];
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R14
        ADDA    R14, R15
        MOV.W   0x12(R15), R12
        RETA
//  411 }
          CFI EndBlock cfiBlock12
//  412 /*******************************************************************************
//  413 *  函数名称：TIMER_Capture_CalTime_Us(uint16_t start_value,uint16_t stop_value,uint16_t overflowTime)
//  414 *  功能说明：读取发生捕获时定时器该通道计数值
//  415 *  参数说明：uint16_t start_value  ：捕获起始值
//  416              uint16_t stop_value   ：捕获结束值
//  417              uint16_t overflowTime ：计数器溢出次数
//  418 *  函数返回：
//  419 *  使用例程：uint16 overflowTime;  //定义变量，在定时器溢出中断里对该值增一
//  420              ......
//  421              TIMER_Capture_CalTime_Us(0,TIMER_Capture_GetValue  (TIMER_A0,TIMER_CH1),overflowTime);  //读取发生捕获时的时间
//  422              overflowTime=0;       //清零
//  423 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  424 uint32_t TIMER_Capture_CalTime_Us(uint16_t start_value,uint16_t stop_value,uint16_t overflowTime)
TIMER_Capture_CalTime_Us:
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function TIMER_Capture_CalTime_Us
//  425 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
//  426   return (uint32_t)((((int32_t)stop_value - (int32_t)start_value) + (uint32_t)overflowTime*65536)/g_sClock.SMCLK.fMHZ);
        MOV.W   R13, R10
        MOV.W   #0x0, R11
        MOV.W   #0x0, R13
        SUB.W   R12, R10
        SUBC.W  R13, R11
        MOV.W   #0x0, R15
        MOV.W   R14, R15
        MOV.W   #0x0, R14
        ADD.W   R14, R10
        ADDC.W  R15, R11
        MOV.W   R10, R12
        MOV.W   R11, R13
          CFI FunCall _Cast32uto32f
        CALLA   #_Cast32uto32f
        MOVX.W  &g_sClock + 20, R14
        MOVX.W  &g_sClock + 22, R15
          CFI FunCall _Div32f
        CALLA   #_Div32f
          CFI FunCall _Cast32fto32u
        CALLA   #_Cast32fto32u
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
//  427 }
          CFI EndBlock cfiBlock13
//  428 /*******************************************************************************
//  429 *  函数名称：TIMER_Timer_Init      (TIMERn timer)
//  430 *  功能说明：计时功能初始化
//  431 *  参数说明：TIMERn timer       ：定时器模块
//  432 *  函数返回：不成功则返回ERROR，成功则返回SUCCESS
//  433 *  使用例程：TIMER_Timer_Init      (TIMER_A1);     //定时器TA1初始化为计时器
//  434 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  435 STATUS   TIMER_Timer_Init      (TIMERn timer)
TIMER_Timer_Init:
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function TIMER_Timer_Init
          CFI NoCalls
//  436 {
//  437 #ifdef DELAY_TIMER
//  438  //ASSERT((timer != DELAY_TIMER),
//  439          "TIMER_Timer_Init",
//  440          "定时器已经设置为默认延时功能，不能再作为其他功能使用");       //不允许这种情况下还宏定义该定时器作为延时所用的定时器，请在system.h里修改DELAY_TIMER宏定义
//  441 #endif
//  442   TIMERX[timer]->CLR = BIT_SET;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        BIS.W   #0x4, 0(R15)
//  443   TIMERX[timer]->SSEL = TIMER_SSEL_SMCLK;             //这里选择子系统时钟
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xfcff, R15
        BIS.W   #0x200, R15
        MOV.B   R12, R14
        RLAM.A  #0x2, R14
        MOVX.A  TIMERX(R14), R14
        MOV.W   R15, 0(R14)
//  444   TIMERX[timer]->ID = 0u; 
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xff3f, 0(R15)
//  445   TIMERX[timer]->MC = TIMER_MC_STOP;                  //先停止计数计数
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xffcf, 0(R15)
//  446   TIMERX[timer]->IE = RESET;                          //禁止溢出中断
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        BIC.W   #0x2, 0(R15)
//  447   
//  448   return SUCCESS;
        MOV.B   #0x1, R12
        RETA
//  449 }
          CFI EndBlock cfiBlock14
//  450 /*******************************************************************************
//  451 *  函数名称：TIMER_Timer_Start(TIMERn timer)
//  452 *  功能说明：计时功能开始计时
//  453 *  参数说明：TIMERn timer       ：定时器模块
//  454 *  函数返回：无
//  455 *  使用例程：TIMER_Timer_Start(TIMER_A1);      //计时器开始计时
//  456 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  457 void   TIMER_Timer_Start(TIMERn timer)
TIMER_Timer_Start:
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function TIMER_Timer_Start
          CFI NoCalls
//  458 {
//  459   TIMERX[timer]->R = 0u;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   #0x0, 0x10(R15)
//  460   TIMERX[timer]->MC = TIMER_MC_CONTINUOUS;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xffcf, R15
        BIS.W   #0x20, R15
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R14
        MOV.W   R15, 0(R14)
//  461 }
        RETA
          CFI EndBlock cfiBlock15
//  462 /*******************************************************************************
//  463 *  函数名称：TIMER_Timer_Stop (TIMERn timer)
//  464 *  功能说明：计时功能停止计时
//  465 *  参数说明：TIMERn timer       ：定时器模块
//  466 *  函数返回：返回当前计数值
//  467 *  使用例程：TIMER_Timer_Stop (TIMER_A1);   //计时器停止计时
//  468 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  469 uint16_t   TIMER_Timer_Stop (TIMERn timer)
TIMER_Timer_Stop:
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function TIMER_Timer_Stop
          CFI NoCalls
//  470 {
//  471    TIMERX[timer]->MC = TIMER_MC_STOP;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        AND.W   #0xffcf, 0(R15)
//  472    return TIMERX[timer]->R;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.W   0x10(R15), R12
        RETA
//  473 }
          CFI EndBlock cfiBlock16
//  474 /*******************************************************************************
//  475 *  函数名称：TIMER_Timer_GetTime_Us(TIMERn timer,uint16_t overflowTime)
//  476 *  功能说明：计时时间读取
//  477 *  参数说明：TIMERn timer       ：定时器模块
//  478              uint16_t overflowTime ：计数器溢出次数
//  479 *  函数返回：返回计时时间 （单位：us）
//  480 *  使用例程：int16 overflowTime;  //定义变量，在定时器溢出中断里对该值增一
//  481              ......
//  482              TIMER_Timer_GetTime_Us(TIMAER_A1,overflowTime);  //读取计时时间
//  483              overflowTime=0;       //清零
//  484 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  485 uint32_t TIMER_Timer_GetTime_Us(TIMERn timer,uint16_t overflowTime)
TIMER_Timer_GetTime_Us:
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function TIMER_Timer_GetTime_Us
//  486 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
//  487   return (uint32_t)((TIMERX[timer]->R + overflowTime*65536u)/g_sClock.SMCLK.fMHZ);
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.W   0x10(R15), R14
        MOV.W   #0x0, R15
        MOV.W   R13, R12
        MOV.W   #0x0, R13
        MOV.W   R12, R13
        MOV.W   #0x0, R12
        ADD.W   R12, R14
        ADDC.W  R13, R15
        MOV.W   R14, R12
        MOV.W   R15, R13
          CFI FunCall _Cast32uto32f
        CALLA   #_Cast32uto32f
        MOVX.W  &g_sClock + 20, R14
        MOVX.W  &g_sClock + 22, R15
          CFI FunCall _Div32f
        CALLA   #_Div32f
          CFI FunCall _Cast32fto32u
        CALLA   #_Cast32fto32u
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
//  488 }
          CFI EndBlock cfiBlock17
//  489 /*******************************************************************************
//  490 *  函数名称：TIMER_Run (TIMERn timer)
//  491 *  功能说明：定时器工作
//  492 *  参数说明：TIMERn timer       ：定时器模块
//  493 *  函数返回：无
//  494 *  使用例程：TIMER_Clear_Counter (TIMAER_A1)；  //启动定时器A1
//  495 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  496 void   TIMER_Run (TIMERn timer)
TIMER_Run:
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function TIMER_Run
          CFI NoCalls
//  497 {
//  498   TIMERX[timer]->MC = TIMER_MC_CONTINUOUS;
        MOV.B   R12, R15
        RLAM.A  #0x2, R15
        MOVX.A  TIMERX(R15), R15
        MOV.W   @R15, R15
        AND.W   #0xffcf, R15
        BIS.W   #0x20, R15
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R14
        MOV.W   R15, 0(R14)
//  499 }
        RETA
          CFI EndBlock cfiBlock18
//  500 /*******************************************************************************
//  501 *  函数名称：TIMER_Stop (TIMERn timer)
//  502 *  功能说明：定时器工作
//  503 *  参数说明：TIMERn timer       ：定时器模块
//  504 *  函数返回：无
//  505 *  使用例程：TIMER_Stop(TIMAER_A1)；  //停止定时器A1
//  506 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  507 void   TIMER_Stop (TIMERn timer)
TIMER_Stop:
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function TIMER_Stop
          CFI NoCalls
//  508 {
//  509   TIMERX[timer]->MC = TIMER_MC_STOP;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        AND.W   #0xffcf, 0(R15)
//  510 }
        RETA
          CFI EndBlock cfiBlock19
//  511 /*******************************************************************************
//  512 *  函数名称：TIMER_GetCounterValue (TIMERn timer)
//  513 *  功能说明：读取定时器计数值
//  514 *  参数说明：TIMERn timer  ：定时器模块
//  515 *  函数返回：uint16_t      ：计数值
//  516 *  使用例程：uint16_t value = TIMER_GetCounterValue(TIMAER_A1)；  //读取定时器A1计数值
//  517 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  518 uint16_t   TIMER_GetCounterValue (TIMERn timer)
TIMER_GetCounterValue:
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function TIMER_GetCounterValue
          CFI NoCalls
//  519 {
//  520   return TIMERX[timer]->R;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.W   0x10(R15), R12
        RETA
//  521 }
          CFI EndBlock cfiBlock20
//  522 /*******************************************************************************
//  523 *  函数名称：TIMER_SetCounterValue(TIMERn timer,uint16_t value)
//  524 *  功能说明：设置定时器计数值
//  525 *  参数说明：TIMERn timer       ：定时器模块
//  526              uint16_t value     ：计数值
//  527 *  函数返回：无
//  528 *  使用例程：TIMER_SetCounterValue(TIMAER_A1,0)；  //设置定时器A1计数值为0
//  529 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  530 void   TIMER_SetCounterValue (TIMERn timer,uint16_t value)
TIMER_SetCounterValue:
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function TIMER_SetCounterValue
          CFI NoCalls
//  531 {
//  532   TIMERX[timer]->R = value;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.W   R13, 0x10(R15)
//  533 }
        RETA
          CFI EndBlock cfiBlock21
//  534 /*******************************************************************************
//  535 *  函数名称：TIMER_GetChannelCounterValue (TIMERn timer,TIMER_CHn ch)
//  536 *  功能说明：读取定时器通道计数值
//  537 *  参数说明：TIMERn timer       ：定时器模块
//  538              TIMER_CHn ch       ：定时器通道             
//  539 *  函数返回：uint16_t value     ：该通道的计数值
//  540 *  使用例程：uint16_t value = TIMER_GetChannelCounterValue(TIMAER_A1,TIMER_CH4)；  //读取定时器A1通道4计数值
//  541 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  542 uint16_t   TIMER_GetChannelCounterValue (TIMERn timer,TIMER_CHn ch)
TIMER_GetChannelCounterValue:
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function TIMER_GetChannelCounterValue
          CFI NoCalls
//  543 {
//  544   //ASSERT((timer==TIMER_A0&&ch<=TIMER_CH4)
//  545 //       ||(timer==TIMER_A1&&ch<=TIMER_CH2)
//  546 //       ||(timer==TIMER_A2&&ch<=TIMER_CH2)
//  547 //       ||(timer==TIMER_B0&&ch<=TIMER_CH6),
//  548 //       "TIMER_GetChannelCounterValue",
//  549 //       "定时器通道参数超出范围！"); //断言检测输入参数
//  550   
//  551   return TIMERX[timer]->CCR[ch];
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R14
        ADDA    R14, R15
        MOV.W   0x12(R15), R12
        RETA
//  552 }
          CFI EndBlock cfiBlock22
//  553 /*******************************************************************************
//  554 *  函数名称：TIMER_SetChannelCounterValue(TIMERn timer,uint16_t value)
//  555 *  功能说明：设置定时器计数值
//  556 *  参数说明：TIMERn timer       ：定时器模块
//  557              TIMER_CHn ch       ：定时器通道
//  558              uint16_t value     ：计数值
//  559 *  函数返回：无
//  560 *  使用例程：TIMER_SetChannelCounterValue(TIMAER_A1,TIMER_CH4,0)；  //设置定时器A1通道4计数值为0
//  561 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  562 void   TIMER_SetChannelCounterValue (TIMERn timer,TIMER_CHn ch,uint16_t value)
TIMER_SetChannelCounterValue:
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function TIMER_SetChannelCounterValue
          CFI NoCalls
//  563 {
//  564   //ASSERT((timer==TIMER_A0&&ch<=TIMER_CH4)
//  565 //       ||(timer==TIMER_A1&&ch<=TIMER_CH2)
//  566 //       ||(timer==TIMER_A2&&ch<=TIMER_CH2)
//  567 //       ||(timer==TIMER_B0&&ch<=TIMER_CH6),
//  568 //       "TIMER_SetChannelCounterValue",
//  569 //       "定时器通道参数超出范围！"); //断言检测输入参数
//  570   
//  571   TIMERX[timer]->CCR[ch] = value;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R12
        ADDA    R12, R15
        MOV.W   R14, 0x12(R15)
//  572 }
        RETA
          CFI EndBlock cfiBlock23
//  573 /*******************************************************************************
//  574 *  函数名称：TIMER_GetChannelPinInValue(TIMERn timer, TIMER_CHn ch)
//  575 *  功能说明：获取通道输入值
//  576 *  参数说明：TIMERn timer       ：定时器模块
//  577              TIMER_CHn ch       ：定时器通道
//  578 *  函数返回：STATUS : BIT_SET-输入高电平 RESET-输入低电平
//  579 *  使用例程：STATUS status = TIMER_GetChannelInValue(TIMAER_A1, TIMER_CH1);  //读取定时器A1通道1输入电平
//  580 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  581 STATUS TIMER_GetChannelPinInValue (TIMERn timer, TIMER_CHn ch)
TIMER_GetChannelPinInValue:
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function TIMER_GetChannelPinInValue
          CFI NoCalls
//  582 {
//  583   return (TIMERX[timer]->CCTL[ch].CH_CCI) ? BIT_SET : RESET;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R14
        ADDA    R14, R15
        MOV.W   0x2(R15), R14
        BIT.B   #0x8, R14
        SUBC.W  R12, R12
        ADD.B   #0x1, R12
        RETA
//  584 }
          CFI EndBlock cfiBlock24
//  585 /*******************************************************************************
//  586 *  函数名称：TIMER_GetChannelPinOutValue(TIMERn timer, TIMER_CHn ch)
//  587 *  功能说明：获取通道输出值
//  588 *  参数说明：TIMERn timer       ：定时器模块
//  589              TIMER_CHn ch       ：定时器通道
//  590 *  函数返回：STATUS : BIT_SET-输出高电平 RESET-输出低电平
//  591 *  使用例程：STATUS status = TIMER_GetChannelOutValue(TIMAER_A1, TIMER_CH1);  //读取定时器A1通道1输出电平
//  592 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  593 STATUS TIMER_GetChannelPinOutValue(TIMERn timer, TIMER_CHn ch)
TIMER_GetChannelPinOutValue:
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function TIMER_GetChannelPinOutValue
          CFI NoCalls
//  594 {
//  595   return (TIMERX[timer]->CCTL[ch].CH_OUT) ? BIT_SET : RESET;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R14
        ADDA    R14, R15
        MOV.W   0x2(R15), R14
        BIT.B   #0x4, R14
        SUBC.W  R12, R12
        ADD.B   #0x1, R12
        RETA
//  596 }
          CFI EndBlock cfiBlock25
//  597 /*******************************************************************************
//  598 *  函数名称：TIMER_ITConfig (TIMERn timer,TIMER_IRQn irqn,STATUS ITState)
//  599 *  功能说明：设置是否使能TIMER的某一个中断
//  600 *  参数说明：TIMERn timer       ：定时器模块
//  601              TIMER_IRQn irqn    ：中断事件
//  602              STATUS ITState     ：是否使能中断
//  603 *  函数返回：无
//  604 *  使用例程：TIMER_ITConfig (TIMAER_A1,TIMER_CCR0_IRQn,ENABLE); //使能定时器1通道0中断，即定时中断
//  605 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  606 void  TIMER_ITConfig (TIMERn timer,TIMER_IRQn irqn,STATUS ITState)
TIMER_ITConfig:
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function TIMER_ITConfig
          CFI NoCalls
//  607 {
//  608   if(irqn == TIMER_OverFlow_IRQn)
        CMP.B   #0x7, R13
        JNE     ??TIMER_ITConfig_2
//  609   {
//  610     TIMERX[timer]->IE = ITState;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        BIT.B   #0x1, R14
        JC      ??TIMER_ITConfig_3
        BIC.W   #0x2, 0(R15)
        RETA
??TIMER_ITConfig_3:
        BIS.W   #0x2, 0(R15)
        RETA
//  611   }
//  612   else
//  613   {
//  614     TIMERX[timer]->CCTL[irqn].IE = ITState;
??TIMER_ITConfig_2:
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R12
        ADDA    R12, R15
        BIT.B   #0x1, R14
        JC      ??TIMER_ITConfig_4
        BIC.W   #0x10, 0x2(R15)
        RETA
??TIMER_ITConfig_4:
        BIS.W   #0x10, 0x2(R15)
//  615   }
//  616 }
        RETA
          CFI EndBlock cfiBlock26
//  617 /*******************************************************************************
//  618 *  函数名称：TIMER_GetITStatus(TIMERn timer,TIMER_IRQn irqn)
//  619 *  功能说明：获取TIMER的某一个中断标志
//  620 *  参数说明：TIMERn timer       ：定时器模块
//  621              TIMER_IRQn irqn    ：中断事件
//  622 *  函数返回：STATUS : TRUE-中断事件发生 FALSE-中断事件未发生
//  623 *  使用例程：if(TRUE == TIMER_GetITStatus(TIMAER_A1,TIMER_CCR1_IRQn)){...} //判断定时器A1通道1中断事件是否发生
//  624 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  625 STATUS TIMER_GetITStatus(TIMERn timer,TIMER_IRQn irqn)
TIMER_GetITStatus:
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function TIMER_GetITStatus
          CFI NoCalls
//  626 {
//  627   if(irqn == TIMER_OverFlow_IRQn)
        CMP.B   #0x7, R13
        JNE     ??TIMER_GetITStatus_0
//  628   {
//  629     return ((TIMERX[timer]->IFG == BIT_SET) ? TRUE : FALSE);
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.W   @R15, R12
        AND.B   #0x1, R12
        RETA
//  630   }
//  631   else
//  632   {
//  633     return ((TIMERX[timer]->CCTL[irqn].IFG == BIT_SET) ? TRUE : FALSE);
??TIMER_GetITStatus_0:
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R14
        ADDA    R14, R15
        MOV.W   0x2(R15), R12
        AND.B   #0x1, R12
        RETA
//  634   }
//  635 }
          CFI EndBlock cfiBlock27
//  636 /*******************************************************************************
//  637 *  函数名称：TIMER_ClearITPendingBit(TIMERn timer,TIMER_IRQn irqn)
//  638 *  功能说明：清除TIMER的某一个中断标志
//  639 *  参数说明：TIMERn timer       ：定时器模块
//  640              TIMER_IRQn irqn    ：中断事件
//  641 *  函数返回：无
//  642 *  使用例程：TIMER_ClearITPendingBit(TIMAER_A1,TIMER_CCR1_IRQn);   //清除定时器通道1中断标志位
//  643 ********************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  644 void  TIMER_ClearITPendingBit(TIMERn timer,TIMER_IRQn irqn)
TIMER_ClearITPendingBit:
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function TIMER_ClearITPendingBit
          CFI NoCalls
//  645 {
//  646   if(irqn == TIMER_OverFlow_IRQn)
        CMP.B   #0x7, R13
        JNE     ??TIMER_ClearITPendingBit_0
//  647   {
//  648     TIMERX[timer]->IFG = RESET;
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        BIC.W   #0x1, 0(R15)
        RETA
//  649   }
//  650   else
//  651   {
//  652     TIMERX[timer]->CCTL[irqn].IFG = RESET;
??TIMER_ClearITPendingBit_0:
        MOV.B   R12, R12
        RLAM.A  #0x2, R12
        MOVX.A  TIMERX(R12), R15
        MOV.B   R13, R13
        ADDA    R13, R13
        MOVA    R13, R14
        ADDA    R14, R15
        BIC.W   #0x1, 0x2(R15)
//  653   }
//  654 }
        RETA
          CFI EndBlock cfiBlock28

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// 
// 3 122 bytes in segment CODE
//    96 bytes in segment DATA20_C
// 
// 3 122 bytes of CODE  memory
//    96 bytes of CONST memory
//
//Errors: none
//Warnings: none
