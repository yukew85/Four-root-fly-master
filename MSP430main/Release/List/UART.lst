###############################################################################
#
# IAR C/C++ Compiler V7.12.1.987/W32 for MSP430           01/Nov/2018  12:43:46
# Copyright 1996-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for Texas Instruments MSP430
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  large
#    __code_model  =  large
#    Source file   =  
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\UART.c
#    Command line  =  
#        -f C:\Users\颜子楠\AppData\Local\Temp\EWE5D0.tmp
#        (C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\UART.c
#        -D NDEBUG -D RAM_VECTOR -lC
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Release\List
#        -lA
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Release\List
#        -o C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Release\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430F5529__ -e --double=32 --dlib_config
#        D:\IAR\430\lib\dlib\dl430xllfn.h -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\ -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\inc\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\USB\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\USB\USB_config\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\USB\USB_User\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\srcUSB\USB_API\USB_CDC_API\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\USB\USB_API\USB_HID_API\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Drivers\src\USB\USB_API\USB_MSC_API\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\KEY\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\LED\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\12864\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\oled\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\mpu6050\inc\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\mpu6050\src\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\nokia5110\inc\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\nokia5110\src\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\LQ_1.8_TFT\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\LCD_API\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\2.2TFT\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\delay\
#        -I C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\System\ -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\System\inc\ -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\System\src\ -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\User\ -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\User\USER\ -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\UCOSII\CONFIG\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\uCOSII\App\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\uCOSII\CONFIHG\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\uCOSII\PORT\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\UCOSII\CORE\
#        -I C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\FatFs\
#        -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Lib\FatFs\option\
#        -I C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\src\ -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\ -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\nrf24l01\
#        -I C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\MATH\ -I
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HAL\
#        --core=430X --data_model=large -Ol --multiplier=32
#        --hw_workaround=CPU40 --hw_workaround=nop_after_lpm -DNDEBUG
#        --code_model=large)
#    Locale        =  Chinese (Simplified)_CHN.936
#    List file     =  
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Release\List\UART.lst
#    Object file   =  
#        C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\Release\Obj\UART.r43
#
###############################################################################

C:\Users\颜子楠\Desktop\教材\附件目录\2.源码\1.飞控源码\HardWare\UART.c
      1          #include "UART.h"
      2          #include "include.h"
      3          

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
      4          unsigned char Rx_Buff[128];
   \                     Rx_Buff:
   \   000000                DS8 128

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
      5          int RX_Cnt=0;
   \                     RX_Cnt:
   \   000000                DS8 2

   \                                 In  segment DATA20_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
      6          bool Rx_Start = false;
   \                     Rx_Start:
   \   000000                DS8 1
      7          extern uint16_t cnt_20ms;
      8          

   \                                 In  segment ISR_CODE, align 2
      9          __interrupt void UART_RX_IRQ_Handler()
   \                     UART_RX_IRQ_Handler:
     10          { 
   \   000000   5F14         PUSHM.A #0x6, R15
     11            int sum = 0;
   \   000002   0A43         MOV.W   #0x0, R10
     12            if(UART_GetITStatus(UART0,UART_RX_IRQn) == TRUE)   //清除串口某一个中断标志
   \   000004   5D43         MOV.B   #0x1, R13
   \   000006   4C43         MOV.B   #0x0, R12
   \   000008   ........     CALLA   #UART_GetITStatus
   \   00000C   5C93         CMP.B   #0x1, R12
   \   00000E   7A20         JNE     ??UART_RX_IRQ_Handler_1
     13            {   
     14              ZKHD_Link_Head_t *ZKHD_Link_Head;
                                       ^
Warning[Pe550]: variable "ZKHD_Link_Head" was set but never used
     15              Rx_Buff[RX_Cnt] = UART_GetChar(UART0);                 //读取一个字节1个字节
   \   000010   4C43         MOV.B   #0x0, R12
   \   000012   ........     CALLA   #UART_GetChar
   \   000016   ....1F42.... MOVX.W  &RX_Cnt, R15
   \   00001C   ....CF4C.... MOVX.B  R12, Rx_Buff(R15)
     16              RX_Cnt++;
   \   000022   ....9253.... ADDX.W  #0x1, &RX_Cnt
     17              UART_ClearITPendingBit(UART0,UART_RX_IRQn);    //清除串口某一个中断标志
   \   000028   5D43         MOV.B   #0x1, R13
   \   00002A   4C43         MOV.B   #0x0, R12
   \   00002C   ........     CALLA   #UART_ClearITPendingBit
     18              
     19              ZKHD_Link_Head = (ZKHD_Link_Head_t*)Rx_Buff;
   \   000030   ........     MOVA    #Rx_Buff, R15
     20              
     21              cnt_20ms = 0;
   \   000034   ....8243.... MOVX.W  #0x0, &cnt_20ms
     22              Rx_Start = true;
   \   00003A   ....D243.... MOVX.B  #0x1, &Rx_Start
     23          //    //AA 05 00 00 01 00 e1 e2 e3 e4 e5 ab 1f
     24              switch(RX_Cnt - 1)
   \   000040   ....1E42.... MOVX.W  &RX_Cnt, R14
   \   000046   3E53         ADD.W   #0xffff, R14
   \   000048   0E83         SUB.W   #0x0, R14
   \   00004A   0624         JEQ     ??UART_RX_IRQ_Handler_7
   \   00004C   3E800300     SUB.W   #0x3, R14
   \   000050   0C24         JEQ     ??UART_RX_IRQ_Handler_8
   \   000052   1E83         SUB.W   #0x1, R14
   \   000054   1224         JEQ     ??UART_RX_IRQ_Handler_9
   \   000056   193C         JMP     ??UART_RX_IRQ_Handler_5
     25                {
     26                    case 0:
     27                        if(Rx_Buff[0] != 0xAA)
   \                     ??UART_RX_IRQ_Handler_7:
   \   000058   ....F290AA00 CMPX.B  #0xaa, &Rx_Buff
   \            ....        
   \   000060   5124         JEQ     ??UART_RX_IRQ_Handler_1
     28                        {
     29                            RX_Cnt = 0;
   \   000062   ....8243.... MOVX.W  #0x0, &RX_Cnt
     30                        }
     31                        break;
   \   000068   4D3C         JMP     ??UART_RX_IRQ_Handler_1
     32                    case 3:
     33                        if(Rx_Buff[3] != 0x00)
   \                     ??UART_RX_IRQ_Handler_8:
   \   00006A   ....C293.... CMPX.B  #0x0, &Rx_Buff + 3
   \   000070   4924         JEQ     ??UART_RX_IRQ_Handler_1
     34                        {
     35                            RX_Cnt = 0;
   \   000072   ....8243.... MOVX.W  #0x0, &RX_Cnt
     36                        }
     37                        break;
   \   000078   453C         JMP     ??UART_RX_IRQ_Handler_1
     38                    case 4:
     39                        if(Rx_Buff[4] != 0x1)
   \                     ??UART_RX_IRQ_Handler_9:
   \   00007A   ....D293.... CMPX.B  #0x1, &Rx_Buff + 4
   \   000080   4124         JEQ     ??UART_RX_IRQ_Handler_1
     40                        {
     41                            RX_Cnt = 0;
   \   000082   ....8243.... MOVX.W  #0x0, &RX_Cnt
     42                        }
     43                        break;
   \   000088   3D3C         JMP     ??UART_RX_IRQ_Handler_1
     44                    default:              
     45                          for(int i=0;i<Rx_Buff[1] + 6;i++)
   \                     ??UART_RX_IRQ_Handler_5:
   \   00008A   0E43         MOV.W   #0x0, R14
   \   00008C   073C         JMP     ??UART_RX_IRQ_Handler_6
     46                          {
     47                              sum += Rx_Buff[i];
   \                     ??UART_RX_IRQ_Handler_0:
   \   00008E   0F4E         MOV.W   R14, R15
   \   000090   ....5F4F.... MOVX.B  Rx_Buff(R15), R15
   \   000096   4F4F         MOV.B   R15, R15
   \   000098   0A5F         ADD.W   R15, R10
     48                          }
   \   00009A   1E53         ADD.W   #0x1, R14
   \                     ??UART_RX_IRQ_Handler_6:
   \   00009C   ....5F42.... MOVX.B  &Rx_Buff + 1, R15
   \   0000A2   4F4F         MOV.B   R15, R15
   \   0000A4   3F500600     ADD.W   #0x6, R15
   \   0000A8   0E9F         CMP.W   R15, R14
   \   0000AA   F13B         JL      ??UART_RX_IRQ_Handler_0
     49                          
     50                        if(Rx_Buff[0] == 0xAA     && 
     51                           Rx_Buff[3] == 0        &&
     52                           Rx_Buff[4] == 1        &&
     53                           ((sum & 0xFF) == (Rx_Buff[Rx_Buff[1] + 6])))
   \   0000AC   ....F290AA00 CMPX.B  #0xaa, &Rx_Buff
   \            ....        
   \   0000B4   2720         JNE     ??UART_RX_IRQ_Handler_1
   \   0000B6   ....C293.... CMPX.B  #0x0, &Rx_Buff + 3
   \   0000BC   2320         JNE     ??UART_RX_IRQ_Handler_1
   \   0000BE   ....D293.... CMPX.B  #0x1, &Rx_Buff + 4
   \   0000C4   1F20         JNE     ??UART_RX_IRQ_Handler_1
   \   0000C6   3AF0FF00     AND.W   #0xff, R10
   \   0000CA   ....5F42.... MOVX.B  &Rx_Buff + 1, R15
   \   0000D0   4F4F         MOV.B   R15, R15
   \   0000D2   3F500600     ADD.W   #0x6, R15
   \   0000D6   ....5F4F.... MOVX.B  Rx_Buff(R15), R15
   \   0000DC   4F4F         MOV.B   R15, R15
   \   0000DE   0A9F         CMP.W   R15, R10
   \   0000E0   1120         JNE     ??UART_RX_IRQ_Handler_1
     54                         {
     55                             if(RX_Cnt == Rx_Buff[1] + 7)
   \   0000E2   ....5F42.... MOVX.B  &Rx_Buff + 1, R15
   \   0000E8   4F4F         MOV.B   R15, R15
   \   0000EA   3F500700     ADD.W   #0x7, R15
   \   0000EE   ....829F.... CMPX.W  R15, &RX_Cnt
   \   0000F4   0720         JNE     ??UART_RX_IRQ_Handler_1
     56                             {
     57                                  ZKHD_Link_Handle(Rx_Buff);
   \   0000F6   ........     MOVA    #Rx_Buff, R12
   \   0000FA   ........     CALLA   #ZKHD_Link_Handle
     58                                  RX_Cnt = 0;
   \   0000FE   ....8243.... MOVX.W  #0x0, &RX_Cnt
     59                             }
     60                         }
     61                        break;
     62                  }
     63            }
     64              //AA 05 00 00 01 00 E1 E2 E3 E4 E5
     65          }
   \                     ??UART_RX_IRQ_Handler_1:
   \   000104   5A16         POPM.A  #0x6, R15
   \   000106   0013         RETI
     66                         

   \                                 In  segment CODE, align 2
     67          void USART_Init()
   \                     USART_Init:
     68          {
     69              UART_Init        (UART0,115200);                      //初始化uartx模块,波特率115200，波特率高时最好把主时钟 设高些
   \   000000   3E4000C2     MOV.W   #0xc200, R14
   \   000004   1F43         MOV.W   #0x1, R15
   \   000006   4C43         MOV.B   #0x0, R12
   \   000008   ........     CALLA   #UART_Init
     70              Set_Vector_Handler(VECTOR_UART0,UART_RX_IRQ_Handler);    //设置接收中断向量
   \   00000C   ........     MOVA    #UART_RX_IRQ_Handler, R13
   \   000010   7C403800     MOV.B   #0x38, R12
   \   000014   ........     CALLA   #Set_Vector_Handler
     71              UART_ITConfig  (UART0,UART_RX_IRQn,TRUE);                //开串口接收中断
   \   000018   5E43         MOV.B   #0x1, R14
   \   00001A   5D43         MOV.B   #0x1, R13
   \   00001C   4C43         MOV.B   #0x0, R12
   \   00001E   ........     CALLA   #UART_ITConfig
     72              UART_ITConfig  (UART0,UART_TX_IRQn,TRUE); 
   \   000022   5E43         MOV.B   #0x1, R14
   \   000024   6D43         MOV.B   #0x2, R13
   \   000026   4C43         MOV.B   #0x0, R12
   \   000028   ........     BRA     #UART_ITConfig
     73          }

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     28   UART_RX_IRQ_Handler
       28   -> UART_ClearITPendingBit
       28   -> UART_GetChar
       28   -> UART_GetITStatus
       28   -> ZKHD_Link_Handle
      4   USART_Init
        4   -> Set_Vector_Handler
        0   -> UART_ITConfig
        4   -> UART_ITConfig
        4   -> UART_Init


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  RX_Cnt
     128  Rx_Buff
       1  Rx_Start
     264  UART_RX_IRQ_Handler
      44  USART_Init

 
  44 bytes in segment CODE
 131 bytes in segment DATA20_Z
 264 bytes in segment ISR_CODE
 
 308 bytes of CODE memory
 131 bytes of DATA memory

Errors: none
Warnings: 1
