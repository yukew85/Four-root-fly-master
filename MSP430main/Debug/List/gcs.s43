///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.12.1.987/W32 for MSP430          20/Nov/2018  19:41:05
// Copyright 1996-2018 IAR Systems AB.
// PC-locked license - IAR Embedded Workbench for Texas Instruments MSP430
//
//    __rt_version  =  3
//    __double_size =  32
//    __reg_r4      =  free
//    __reg_r5      =  free
//    __pic         =  no
//    __core        =  430X
//    __data_model  =  large
//    __code_model  =  large
//    Source file   =  
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\GCS\gcs.c
//    Command line  =  
//        -f C:\Users\颜子楠\AppData\Local\Temp\EW2D31.tmp
//        (D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\GCS\gcs.c
//        -D DEBUG -D RAM_VECTOR -lA
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Debug\List
//        -o
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Debug\Obj
//        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
//        -D__MSP430F5529__ -e --double=32 --dlib_config
//        D:\IAR\430\lib\dlib\dl430xllff.h -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Drivers\inc\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Drivers\src\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HardWare\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HardWare\delay\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HardWare\nrf24l01\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\System\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\System\inc\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\System\src\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\User\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\User\USER\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HardWare\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\MATH\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HAL\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\src\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Communication\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Control\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\DataBase\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\GCS\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\MidWare\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\driverlib\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\driverlib\inc\
//        --core=430X --data_model=large -On --multiplier=32
//        --hw_workaround=CPU40 --hw_workaround=nop_after_lpm
//        --code_model=large)
//    Locale        =  Chinese (Simplified)_CHN.936
//    List file     =  
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Debug\List\gcs.s43
//
///////////////////////////////////////////////////////////////////////////////

        NAME gcs

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__code_model", "large"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "large"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?ShiftLeft32_6
        EXTERN _Cast32sto32f
        EXTERN _Div32f
        EXTERN _Add32f
        EXTERN _Mul32f
        EXTERN _Cast32fto32s
        EXTERN ?DivMod32u
        EXTERN ?cstart_init_zero20
        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5
        PUBLIC PID_select
        PUBLIC PollingGCS
        PUBLIC UpdateToGCSAltitude
        PUBLIC UpdateToGCSAttitude
        PUBLIC UpdateToGCSFreq
        PUBLIC UpdateToGCSHardwareInfo
        PUBLIC UpdateToGCSLine
        PUBLIC UpdateToGCSLine2
        PUBLIC UpdateToGCSMPU6050
        PUBLIC UpdateToGCSMotor
        PUBLIC UpdateToGCSPidInfo
        PUBLIC UpdateUSBQueue
        PUBLIC g_UAVinfo
        PUBLIC gcs_ReceiveHandle
        PUBLIC gcs_init
        
          CFI Names cfiNames0
          CFI StackFrame CFA SP DATA
          CFI Resource PC:20, SP:20, SR:16, R4L:16, R4H:4, R4:20, R5L:16, R5H:4
          CFI Resource R5:20, R6L:16, R6H:4, R6:20, R7L:16, R7H:4, R7:20, R8L:16
          CFI Resource R8H:4, R8:20, R9L:16, R9H:4, R9:20, R10L:16, R10H:4
          CFI Resource R10:20, R11L:16, R11H:4, R11:20, R12L:16, R12H:4, R12:20
          CFI Resource R13L:16, R13H:4, R13:20, R14L:16, R14H:4, R14:20, R15L:16
          CFI Resource R15H:4, R15:20
          CFI ResourceParts R4 R4H, R4L
          CFI ResourceParts R5 R5H, R5L
          CFI ResourceParts R6 R6H, R6L
          CFI ResourceParts R7 R7H, R7L
          CFI ResourceParts R8 R8H, R8L
          CFI ResourceParts R9 R9H, R9L
          CFI ResourceParts R10 R10H, R10L
          CFI ResourceParts R11 R11H, R11L
          CFI ResourceParts R12 R12H, R12L
          CFI ResourceParts R13 R13H, R13L
          CFI ResourceParts R14 R14H, R14L
          CFI ResourceParts R15 R15H, R15L
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 2
          CFI ReturnAddress PC CODE
          CFI CFA SP+4
          CFI PC Frame(CFA, -4)
          CFI SR Undefined
          CFI R4L SameValue
          CFI R4H SameValue
          CFI R4 Concat
          CFI R5L SameValue
          CFI R5H SameValue
          CFI R5 Concat
          CFI R6L SameValue
          CFI R6H SameValue
          CFI R6 Concat
          CFI R7L SameValue
          CFI R7H SameValue
          CFI R7 Concat
          CFI R8L SameValue
          CFI R8H SameValue
          CFI R8 Concat
          CFI R9L SameValue
          CFI R9H SameValue
          CFI R9 Concat
          CFI R10L SameValue
          CFI R10H SameValue
          CFI R10 Concat
          CFI R11L SameValue
          CFI R11H SameValue
          CFI R11 Concat
          CFI R12L Undefined
          CFI R12H Undefined
          CFI R12 Undefined
          CFI R13L Undefined
          CFI R13H Undefined
          CFI R13 Undefined
          CFI R14L Undefined
          CFI R14H Undefined
          CFI R14 Undefined
          CFI R15L Undefined
          CFI R15H Undefined
          CFI R15 Undefined
          CFI EndCommon cfiCommon0
        
        EXTERN HeightInfo
        EXTERN g_Attitude
        EXTERN motor
        EXTERN g_MPUManager
        EXTERN g_NRFManager
        EXTERN Remote
        EXTERN g_FMUflg
        EXTERN PIDGroup
        EXTERN ZKHD_Link_MakeFrame
        EXTERN USB_Send_Queue
        EXTERN enQueue
        EXTERN deQueue
        EXTERN U2_UCA1_Send
        EXTERN memcpy

// D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\GCS\gcs.c
//    1 /**
//    2   ******************************************************************************
//    3   * Copyright (c) 2018,北京中科浩电科技有限公司
//    4   * All rights reserved.
//    5   * 文件名称：gcs.c
//    6   * 摘    要：
//    7   *
//    8   * 当前版本：V1.0
//    9   * 作    者：北京中科浩电科技有限公司研发部 
//   10   * 完成日期：    
//   11   * 修改说明：
//   12   * 
//   13   *
//   14   * 历史版本：
//   15   *
//   16   *
//   17   *******************************************************************************/
//   18 
//   19 /*==============================================================================
//   20                          ##### How to use this driver #####
//   21 ==============================================================================
//   22 地面站驱动可按如下方式使用：
//   23 1.调用 gcs_init() 函数，以初始化指针指向；
//   24 2.将地面站发送到飞控的数据写入函数 ZKHD_Link_GCS_To_FMU_Handle() 中；
//   25 3.以一定周期调用如下函数即可在地面站中看到飞控当前信息；
//   26 UpdateToGCSPidInfo();
//   27 UpdateToGCSAttitude();
//   28 UpdateToGCSAltitude();
//   29 UpdateToGCSMPU6050();
//   30 UpdateToGCSMotor();
//   31 UpdateToGCSHardwareInfo();
//   32 UpdateToGCSFreq();
//   33 */
//   34 //外部文件引用
//   35 #include "gcs.h"
//   36 #include "ZKHD_Link.h"
//   37 #include "height_control.h"
//   38 #include "fmuConfig.h"
//   39 #include "UART.h"
//   40 
//   41 //宏定义区
//   42 
//   43 
//   44 
//   45 //Extern引用
//   46 extern Queue_t USB_Send_Queue;
//   47 extern PIDInfo_t *(pPidObject[]);
//   48 
//   49 
//   50 //私有函数区
//   51 
//   52 
//   53 
//   54 //私有变量区

        RSEG DATA20_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero20
//   55 UAV_info_t g_UAVinfo;
g_UAVinfo:
        DS8 36

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
//   56 uint8_t PID_select;
PID_select:
        DS8 1
//   57 
//   58 /******************************************************************************
//   59   * 函数名称：gcs_init
//   60   * 函数描述：初始化地面站相关指针指向
//   61   * 输    入：void
//   62   * 输    出：void
//   63   * 返    回：void
//   64   * 备    注：null    
//   65   *    
//   66   *
//   67 ******************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//   68 void gcs_init(void)
gcs_init:
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function gcs_init
          CFI NoCalls
//   69 {
//   70     g_UAVinfo.Alt = &HeightInfo;
        MOVX.A  #HeightInfo, &g_UAVinfo + 16
//   71     g_UAVinfo.AngE = &g_Attitude;
        MOVX.A  #g_Attitude, &g_UAVinfo + 28
//   72     g_UAVinfo.Firmware_Ver = FIRMWARE_INFO;
        MOVX.B  #0x66, &g_UAVinfo + 4
//   73     g_UAVinfo.Motor = motor;
        MOVX.A  #motor, &g_UAVinfo + 6
//   74     g_UAVinfo.Mpu6050 = &g_MPUManager;
        MOVX.A  #g_MPUManager, &g_UAVinfo + 20
//   75     g_UAVinfo.NRF_MannagerPtr = &g_NRFManager;
        MOVX.A  #g_NRFManager, &g_UAVinfo + 12
//   76     g_UAVinfo.Remote = &Remote;
        MOVX.A  #Remote, &g_UAVinfo + 24
//   77     g_UAVinfo.FMUflg = &g_FMUflg;
        MOVX.A  #g_FMUflg, &g_UAVinfo + 32
//   78 }
        RETA
          CFI EndBlock cfiBlock0
//   79 
//   80 /******************************************************************************
//   81   * 函数名称：gcs_ReceiveHandle
//   82   * 函数描述：地面站接收处理函数
//   83   * 输    入：ZKHD_Link_Head_t *ZKHD_Link_Info：ZKHD_Link协议头
//   84               uint8_t *ptr：实际数据地址
//   85               uint8_t length：实际数据长度
//   86   * 输    出：void
//   87   * 返    回：void
//   88   * 备    注：null   
//   89   *
//   90   *
//   91 ******************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//   92 void gcs_ReceiveHandle(ZKHD_Link_Head_t *ZKHD_Link_Info, uint8_t *ptr, uint8_t length)
gcs_ReceiveHandle:
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function gcs_ReceiveHandle
//   93 {
        PUSHM.A #0x6, R11
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+28
        MOVA    R12, R9
        MOVA    R13, R10
        MOV.B   R14, R6
//   94     PID_Config_t *PID_Config_Info;
//   95     float *base = 0;
        MOVA    #0x0, R8
//   96     
//   97     switch(ZKHD_Link_Info->Message_ID)
        MOV.B   0x5(R9), R14
        SUB.B   #0x0, R14
        JEQ     ??gcs_ReceiveHandle_1
        SUB.B   #0x1, R14
        JEQ     ??gcs_ReceiveHandle_2
        SUB.B   #0x1, R14
        JEQ     ??gcs_ReceiveHandle_3
        SUB.B   #0x1, R14
        JEQ     ??gcs_ReceiveHandle_4
        SUB.B   #0x1, R14
        JEQ     ??gcs_ReceiveHandle_5
        JMP     ??gcs_ReceiveHandle_0
//   98     {
//   99         case MsgID_0_Set_PID:
//  100             
//  101             PID_Config_Info = (PID_Config_t*)ptr;
??gcs_ReceiveHandle_1:
        MOVA    R10, R11
//  102             
//  103             base = &PIDGroup[PID_Config_Info->PID_Select].kp;
        MOV.B   @R11, R15
        SXT     R15
        RPT     #0x6
        RLAX.A  R15
        ADDA    #PIDGroup, R15
        MOVA    R15, R8
//  104             base += PID_Config_Info->PID_Offset;
        MOV.B   0x2(R11), R15
        SXT     R15
        RLAM.A  #0x2, R15
        MOVA    R15, R14
        ADDA    R14, R8
//  105             *base += PID_Config_Info->PID_Set / 10.0f;
        MOV.B   0x3(R11), R12
        SXT     R12
        AND.W   #0xffff, R12
        MOV.W   R12, R13
        RLA.W   R13
        SUBC.W  R13, R13
        XOR.W   #0xffff, R13
          CFI FunCall _Cast32sto32f
        CALLA   #_Cast32sto32f
        MOV.W   #0x0, R14
        MOV.W   #0x4120, R15
          CFI FunCall _Div32f
        CALLA   #_Div32f
        MOV.W   @R8, R14
        MOV.W   0x2(R8), R15
          CFI FunCall _Add32f
        CALLA   #_Add32f
        MOV.W   R12, 0(R8)
        MOV.W   R13, 0x2(R8)
//  106             break;
        JMP     ??gcs_ReceiveHandle_0
//  107         case MsgID_1_Select_PID:
//  108             PID_select = *ptr;
??gcs_ReceiveHandle_2:
        MOVX.B  @R10, &PID_select
//  109             break;
        JMP     ??gcs_ReceiveHandle_0
//  110         case MsgID_2_Set_RxAddr:
//  111             g_UAVinfo.NRF_MannagerPtr->update_rx_Addr(ptr);
??gcs_ReceiveHandle_3:
        MOVA    R10, R12
        MOVA    &g_UAVinfo + 12, R15
        MOVA    0x14(R15), R15
          CFI FunCall
        CALLA   R15
//  112             break;
        JMP     ??gcs_ReceiveHandle_0
//  113         case MsgID_3_Set_RxFreq:
//  114             g_UAVinfo.NRF_MannagerPtr->update_frequency(ptr[0]);
??gcs_ReceiveHandle_4:
        MOV.B   @R10, R12
        MOVA    &g_UAVinfo + 12, R15
        MOVA    0x1c(R15), R15
          CFI FunCall
        CALLA   R15
//  115             break;
        JMP     ??gcs_ReceiveHandle_0
//  116         case MsgID_4_Set_TxAddr:
//  117             g_UAVinfo.NRF_MannagerPtr->update_tx_Addr(ptr);
??gcs_ReceiveHandle_5:
        MOVA    R10, R12
        MOVA    &g_UAVinfo + 12, R15
        MOVA    0x18(R15), R15
          CFI FunCall
        CALLA   R15
//  118             break;
//  119         default:
//  120             break;
//  121     }
//  122 }
??gcs_ReceiveHandle_0:
        POPM.A  #0x6, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock1
//  123 
//  124 /******************************************************************************
//  125   * 函数名称：UpdateToGCSPidInfo
//  126   * 函数描述：更新飞控PID信息到地面站中
//  127   * 输    入：void
//  128   * 输    出：void
//  129   * 返    回：void
//  130   * 备    注：null     
//  131   *    
//  132   *
//  133 ******************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  134 void UpdateToGCSPidInfo()
UpdateToGCSPidInfo:
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function UpdateToGCSPidInfo
//  135 {
        PUSHM.A #0x2, R11
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+12
        SUBA    #0x32, SP
          CFI CFA SP+62
//  136     static uint8_t yaobai = 0;
//  137     int16_t RawBuff[8];
//  138     uint8_t SendBuff[32];
//  139     uint8_t SendLength;
//  140     
//  141     float *ptr = &PIDGroup[PID_select * 2 + yaobai].kp;
        MOVX.B  &PID_select, R10
        MOV.B   R10, R10
        RLA.W   R10
        MOVX.B  &??yaobai, R15
        MOV.B   R15, R15
        ADD.W   R15, R10
        RLAM.A  #0x4, R10
        RRAM.A  #0x4, R10
        RPT     #0x6
        RLAX.A  R10
        ADDA    #PIDGroup, R10
//  142 
//  143     if(yaobai)
        CMPX.B  #0x0, &??yaobai
        JEQ     ??UpdateToGCSPidInfo_2
//  144     {
//  145         yaobai = 0;
        MOVX.B  #0x0, &??yaobai
        JMP     ??UpdateToGCSPidInfo_1
//  146     }
//  147     else
//  148     {
//  149         yaobai = 1;
??UpdateToGCSPidInfo_2:
        MOVX.B  #0x1, &??yaobai
//  150     }
//  151     
//  152     RawBuff[0] = PID_select;
??UpdateToGCSPidInfo_1:
        MOVX.B  &PID_select, R15
        MOV.B   R15, R15
        MOV.W   R15, 0x2(SP)
//  153     RawBuff[0] |= yaobai<<8;
        MOVX.B  &??yaobai, R15
        MOV.B   R15, R15
        AND.W   #0xff, R15
        SWPB    R15
        BIS.W   R15, 0x2(SP)
//  154     
//  155     for(int i = 0; i < 7; i++)
        MOV.W   #0x0, R11
??UpdateToGCSPidInfo_0:
        CMP.W   #0x7, R11
        JGE     ??UpdateToGCSPidInfo_3
//  156     {
//  157         RawBuff[i + 1] = (int16_t)(*ptr++ * 100);
        MOV.W   @R10, R12
        MOV.W   0x2(R10), R13
        MOV.W   #0x0, R14
        MOV.W   #0x42c8, R15
          CFI FunCall _Mul32f
        CALLA   #_Mul32f
          CFI FunCall _Cast32fto32s
        CALLA   #_Cast32fto32s
        MOVA    SP, R14
        ADDA    #0x2, R14
        MOV.W   R11, R15
        ADD.W   #0x1, R15
        ADDA    R15, R15
        ADDA    R14, R15
        MOV.W   R12, 0(R15)
        ADDA    #0x4, R10
//  158     }
        ADD.W   #0x1, R11
        JMP     ??UpdateToGCSPidInfo_0
//  159     
//  160     ZKHD_Link_MakeFrame( Device_FMU,
//  161                         Device_GCS,
//  162                         MsgID_6_PID_Info,
//  163                         (uint8_t*)RawBuff,
//  164                         16,
//  165                         SendBuff,
//  166                         &SendLength
//  167                         );
??UpdateToGCSPidInfo_3:
        MOVA    SP, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+66
        MOVA    SP, R15
        ADDA    #0x16, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+70
        PUSH.W  #0x10
          CFI CFA SP+72
        MOVA    SP, R15
        ADDA    #0xc, R15
        MOV.B   #0x6, R14
        MOV.B   #0x0, R13
        MOV.B   #0x1, R12
          CFI FunCall ZKHD_Link_MakeFrame
        CALLA   #ZKHD_Link_MakeFrame
//  168 
//  169     enQueue(&USB_Send_Queue, SendBuff, SendLength);
        MOV.B   0xa(SP), R14
        MOVA    SP, R13
        ADDA    #0x1c, R13
        MOVA    #USB_Send_Queue, R12
          CFI FunCall enQueue
        CALLA   #enQueue
//  170     
//  171     if(g_UAVinfo.Connect_Port == Connect_Port_NRF)
        ADDA    #0xa, SP
          CFI CFA SP+62
        CMPX.B  #0x1, &g_UAVinfo + 10
        JNE     ??UpdateToGCSPidInfo_4
//  172     {
//  173         g_UAVinfo.NRF_MannagerPtr->send_buff(SendBuff);
        MOVA    SP, R12
        ADDA    #0x12, R12
        MOVA    &g_UAVinfo + 12, R15
        MOVA    0x20(R15), R15
          CFI FunCall
        CALLA   R15
//  174     }
//  175 }
??UpdateToGCSPidInfo_4:
        ADDA    #0x32, SP
          CFI CFA SP+12
        POPM.A  #0x2, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock2

        RSEG DATA20_Z:DATA:SORT:NOROOT(0)
        REQUIRE ?cstart_init_zero20
??yaobai:
        DS8 1
//  176 
//  177 /******************************************************************************
//  178   * 函数名称：PollingGCS
//  179   * 函数描述：轮询发送GCS的数据
//  180   * 输    入：void
//  181   * 输    出：void
//  182   * 返    回：void 
//  183   * 备    注：固定10ms运行一次
//  184   *    
//  185   *
//  186 ******************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  187 void PollingGCS()
PollingGCS:
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function PollingGCS
//  188 {
//  189     static uint32_t Cnt = 0;
//  190     
//  191     if(Cnt % 100 == 0)
        MOV.W   #0x64, R14
        MOV.W   #0x0, R15
        MOVX.W  &??Cnt, R12
        MOVX.W  &??Cnt + 2, R13
          CFI FunCall ?DivMod32u
        CALLA   #?DivMod32u
        MOV.W   R14, R13
        ADDA    R15, R13
        JNE     ??PollingGCS_0
//  192     {
//  193         g_UAVinfo.Runtime++;
        ADDX.W  #0x1, &g_UAVinfo
        ADDCX.W #0x0, &g_UAVinfo + 2
//  194     }
//  195     
//  196     if(ISRATE(RATE_5HZ))
??PollingGCS_0:
        MOV.W   #0x14, R14
        MOV.W   #0x0, R15
        MOVX.W  &??Cnt, R12
        MOVX.W  &??Cnt + 2, R13
          CFI FunCall ?DivMod32u
        CALLA   #?DivMod32u
        MOV.W   R14, R13
        ADDA    R15, R13
        JNE     ??PollingGCS_1
//  197     {
//  198         UpdateToGCSFreq();
          CFI FunCall UpdateToGCSFreq
        CALLA   #UpdateToGCSFreq
//  199         UpdateToGCSHardwareInfo();
          CFI FunCall UpdateToGCSHardwareInfo
        CALLA   #UpdateToGCSHardwareInfo
//  200     }
//  201     
//  202     if(ISRATE(RATE_50HZ))
??PollingGCS_1:
        BITX.W  #0x1, &??Cnt
        JC      ??PollingGCS_2
//  203     {
//  204         UpdateToGCSAttitude();
          CFI FunCall UpdateToGCSAttitude
        CALLA   #UpdateToGCSAttitude
//  205     }
//  206     
//  207     Cnt++;
??PollingGCS_2:
        ADDX.W  #0x1, &??Cnt
        ADDCX.W #0x0, &??Cnt + 2
//  208     UpdateUSBQueue();
          CFI TailCall UpdateUSBQueue
        BRA     #UpdateUSBQueue
//  209 }
          CFI EndBlock cfiBlock3

        RSEG DATA20_Z:DATA:SORT:NOROOT(1)
        REQUIRE ?cstart_init_zero20
??Cnt:
        DS8 4
//  210 
//  211 /******************************************************************************
//  212   * 函数名称：UpdateUSBQueue
//  213   * 函数描述：从USB队列中取出数据发送
//  214   * 输    入：void
//  215   * 输    出：void
//  216   * 返    回：void 
//  217   * 备    注：固定周期运行    
//  218   *    
//  219   *
//  220 ******************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  221 void UpdateUSBQueue()
UpdateUSBQueue:
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function UpdateUSBQueue
//  222 {
        SUBA    #0x22, SP
          CFI CFA SP+38
//  223     uint8_t Buff[QUEUE_DATA_MAXLENGTH];
//  224     uint8_t length;
//  225     
//  226     if (deQueue(&USB_Send_Queue, Buff,&length))
        MOVA    SP, R14
        MOVA    SP, R13
        ADDA    #0x2, R13
        MOVA    #USB_Send_Queue, R12
          CFI FunCall deQueue
        CALLA   #deQueue
        CMP.B   #0x0, R12
        JEQ     ??UpdateUSBQueue_0
//  227     {
//  228         U2_UCA1_Send(Buff, length);
        MOV.B   @SP, R13
        MOVA    SP, R12
        ADDA    #0x2, R12
          CFI FunCall U2_UCA1_Send
        CALLA   #U2_UCA1_Send
//  229     }
//  230 }
??UpdateUSBQueue_0:
        ADDA    #0x22, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock4
//  231 
//  232 /******************************************************************************
//  233   * 函数名称：UpdateToGCSAttitude
//  234   * 函数描述：更新飞控姿态信息到地面站中
//  235   * 输    入：void
//  236   * 输    出：void
//  237   * 返    回：void
//  238   * 备    注：null      
//  239   *    
//  240   *
//  241 ******************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  242 void UpdateToGCSAttitude(void)
UpdateToGCSAttitude:
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function UpdateToGCSAttitude
//  243 {
        PUSHM.A #0x1, R10
          CFI R10L Frame(CFA, -8)
          CFI R10H Frame(CFA, -6)
          CFI CFA SP+8
        SUBA    #0x1a, SP
          CFI CFA SP+34
//  244     uint8_t Buff[20];
//  245     int16_t Angle_Int16[3];
//  246     int sum = 0;
        MOV.W   #0x0, R10
//  247     Buff[0] = 0xAA; //帧头
        MOV.B   #0xaa, 0x6(SP)
//  248     Buff[1] = 6;   //长度低八位
        MOV.B   #0x6, 0x7(SP)
//  249     Buff[2] = 0;    //长度高八位
        MOV.B   #0x0, 0x8(SP)
//  250     Buff[3] = 1;    //发送者ID
        MOV.B   #0x1, 0x9(SP)
//  251     Buff[4] = 0;    //接收者ID
        MOV.B   #0x0, 0xa(SP)
//  252     Buff[5] = 0;    //消息ID
        MOV.B   #0x0, 0xb(SP)
//  253 
//  254     Angle_Int16[0] = (int16_t)(-g_Attitude.pitch * 100);
        MOVX.W  &g_Attitude + 4, R12
        MOVX.W  &g_Attitude + 6, R13
        XOR.W   #0x8000, R13
        MOV.W   #0x0, R14
        MOV.W   #0x42c8, R15
          CFI FunCall _Mul32f
        CALLA   #_Mul32f
          CFI FunCall _Cast32fto32s
        CALLA   #_Cast32fto32s
        MOV.W   R12, 0(SP)
//  255     Angle_Int16[1] = (int16_t)(-g_Attitude.roll * 100);
        MOVX.W  &g_Attitude, R12
        MOVX.W  &g_Attitude + 2, R13
        XOR.W   #0x8000, R13
        MOV.W   #0x0, R14
        MOV.W   #0x42c8, R15
          CFI FunCall _Mul32f
        CALLA   #_Mul32f
          CFI FunCall _Cast32fto32s
        CALLA   #_Cast32fto32s
        MOV.W   R12, 0x2(SP)
//  256     Angle_Int16[2] = (int16_t)(g_Attitude.yaw * 100);
        MOVX.W  &g_Attitude + 8, R12
        MOVX.W  &g_Attitude + 10, R13
        MOV.W   #0x0, R14
        MOV.W   #0x42c8, R15
          CFI FunCall _Mul32f
        CALLA   #_Mul32f
          CFI FunCall _Cast32fto32s
        CALLA   #_Cast32fto32s
        MOV.W   R12, 0x4(SP)
//  257 
//  258     memcpy(Buff + 6,(uint8_t*)Angle_Int16, 6);
        MOV.W   #0x6, R14
        MOV.W   #0x0, R15
        MOVA    SP, R13
        MOVA    SP, R12
        ADDA    #0xc, R12
          CFI FunCall memcpy
        CALLA   #memcpy
//  259 
//  260     for(int i = 0; i<((Buff[1]|Buff[2] <<8) + 6); i++)
        MOV.W   #0x0, R13
??UpdateToGCSAttitude_0:
        MOV.B   0x7(SP), R14
        MOV.B   R14, R14
        MOV.B   0x8(SP), R15
        MOV.B   R15, R15
        AND.W   #0xff, R15
        SWPB    R15
        BIS.W   R15, R14
        ADD.W   #0x6, R14
        CMP.W   R14, R13
        JGE     ??UpdateToGCSAttitude_1
//  261     {
//  262         sum += Buff[i];
        MOVA    SP, R15
        ADDA    #0x6, R15
        MOV.W   R13, R14
        ADDA    R15, R14
        MOV.B   @R14, R15
        MOV.B   R15, R15
        ADD.W   R15, R10
//  263     }
        ADD.W   #0x1, R13
        JMP     ??UpdateToGCSAttitude_0
//  264 
//  265     Buff[(Buff[1]|Buff[2] << 8) + 6] = sum & 0xFF;
??UpdateToGCSAttitude_1:
        MOVA    SP, R13
        ADDA    #0x6, R13
        MOV.B   0x7(SP), R15
        MOV.B   R15, R15
        MOV.B   0x8(SP), R14
        MOV.B   R14, R14
        AND.W   #0xff, R14
        SWPB    R14
        BIS.W   R14, R15
        ADD.W   #0x6, R15
        ADDA    R13, R15
        MOV.B   R10, 0(R15)
//  266     sum = 0;
        MOV.W   #0x0, R10
//  267     
//  268     enQueue(&USB_Send_Queue, Buff,(Buff[1]|Buff[2] << 8) + 7);
        MOV.B   0x7(SP), R14
        ADD.B   #0x7, R14
        MOVA    SP, R13
        ADDA    #0x6, R13
        MOVA    #USB_Send_Queue, R12
          CFI FunCall enQueue
        CALLA   #enQueue
//  269 }
        ADDA    #0x1a, SP
          CFI CFA SP+8
        POPM.A  #0x1, R10
          CFI R10H SameValue
          CFI R10L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock5
//  270 
//  271 /******************************************************************************
//  272   * 函数名称：UpdateToGCSAltitude
//  273   * 函数描述：更新飞控高度信息到地面站中
//  274   * 输    入：void
//  275   * 输    出：void
//  276   * 返    回：void
//  277   * 备    注：null      
//  278   *    
//  279   *
//  280 ******************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  281 void UpdateToGCSAltitude(void)
UpdateToGCSAltitude:
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function UpdateToGCSAltitude
//  282 {
        SUBA    #0x2c, SP
          CFI CFA SP+48
//  283     uint8_t DataBuff[20];
//  284     uint8_t SendBuff[20];
//  285     uint8_t SendLength;
//  286     volatile int16_t Alt = 0;
        MOV.W   #0x0, 0(SP)
//  287     
//  288     Alt = (int16_t)(g_UAVinfo.Alt->Alt * 100);
        MOVA    &g_UAVinfo + 16, R15
        MOV.W   0xc(R15), R12
        MOV.W   0xe(R15), R13
        MOV.W   #0x0, R14
        MOV.W   #0x42c8, R15
          CFI FunCall _Mul32f
        CALLA   #_Mul32f
          CFI FunCall _Cast32fto32s
        CALLA   #_Cast32fto32s
        MOV.W   R12, 0(SP)
//  289     
//  290     memcpy(DataBuff,(uint8_t *)&Alt, 2);
        MOV.W   #0x2, R14
        MOV.W   #0x0, R15
        MOVA    SP, R13
        MOVA    SP, R12
        ADDA    #0x18, R12
          CFI FunCall memcpy
        CALLA   #memcpy
//  291 
//  292     ZKHD_Link_MakeFrame( Device_FMU,
//  293                     Device_GCS,
//  294                     MsgID_4_Alt_Info,
//  295                     DataBuff,
//  296                     2,
//  297                     SendBuff,
//  298                     &SendLength
//  299                    );
        MOVA    SP, R15
        ADDA    #0x2, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+52
        MOVA    SP, R15
        ADDA    #0x8, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+56
        PUSH.W  #0x2
          CFI CFA SP+58
        MOVA    SP, R15
        ADDA    #0x22, R15
        MOV.B   #0x4, R14
        MOV.B   #0x0, R13
        MOV.B   #0x1, R12
          CFI FunCall ZKHD_Link_MakeFrame
        CALLA   #ZKHD_Link_MakeFrame
//  300     
//  301     enQueue(&USB_Send_Queue, SendBuff, SendLength);
        MOV.B   0xc(SP), R14
        MOVA    SP, R13
        ADDA    #0xe, R13
        MOVA    #USB_Send_Queue, R12
          CFI FunCall enQueue
        CALLA   #enQueue
//  302 }
        ADDA    #0x36, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock6
//  303 
//  304 /******************************************************************************
//  305   * 函数名称：UpdateToGCSMPU6050
//  306   * 函数描述：更新g_MPUManager传感器信息到地面站中
//  307   * 输    入：void
//  308   * 输    出：void
//  309   * 返    回：void
//  310   * 备    注：null      
//  311   *    
//  312   *
//  313 ******************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  314 void UpdateToGCSMPU6050(void)
UpdateToGCSMPU6050:
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function UpdateToGCSMPU6050
//  315 {
        SUBA    #0x2a, SP
          CFI CFA SP+46
//  316     uint8_t DataBuff[20];
//  317     uint8_t SendBuff[20];
//  318     uint8_t SendLength;
//  319     
//  320     memcpy(DataBuff,(uint8_t*)g_UAVinfo.Mpu6050, sizeof(MPU6050Manager_t));
        MOV.W   #0x1a, R14
        MOV.W   #0x0, R15
        MOVA    &g_UAVinfo + 20, R13
        MOVA    SP, R12
        ADDA    #0x16, R12
          CFI FunCall memcpy
        CALLA   #memcpy
//  321 
//  322     ZKHD_Link_MakeFrame( Device_FMU,
//  323                     Device_GCS,
//  324                     MsgID_2_Sensor_Info,
//  325                     DataBuff,
//  326                     12,
//  327                     SendBuff,
//  328                     &SendLength
//  329                    );
        MOVA    SP, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+50
        MOVA    SP, R15
        ADDA    #0x6, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+54
        PUSH.W  #0xc
          CFI CFA SP+56
        MOVA    SP, R15
        ADDA    #0x20, R15
        MOV.B   #0x2, R14
        MOV.B   #0x0, R13
        MOV.B   #0x1, R12
          CFI FunCall ZKHD_Link_MakeFrame
        CALLA   #ZKHD_Link_MakeFrame
//  330     
//  331     enQueue(&USB_Send_Queue, SendBuff, SendLength);
        MOV.B   0xa(SP), R14
        MOVA    SP, R13
        ADDA    #0xc, R13
        MOVA    #USB_Send_Queue, R12
          CFI FunCall enQueue
        CALLA   #enQueue
//  332 }
        ADDA    #0x34, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock7
//  333 
//  334 /******************************************************************************
//  335   * 函数名称：UpdateToGCSMotor
//  336   * 函数描述：更新电机输出信息到地面站中
//  337   * 输    入：void
//  338   * 输    出：void
//  339   * 返    回：void
//  340   * 备    注：null      
//  341   *
//  342   *
//  343 ******************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  344 void UpdateToGCSMotor(void)
UpdateToGCSMotor:
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function UpdateToGCSMotor
//  345 {
        SUBA    #0x1e, SP
          CFI CFA SP+34
//  346     uint8_t DataBuff[8];
//  347     uint8_t SendBuff[20];
//  348     uint8_t SendLength;
//  349     
//  350     memcpy(DataBuff, g_UAVinfo.Motor, sizeof(int16_t)*4);
        MOV.W   #0x8, R14
        MOV.W   #0x0, R15
        MOVA    &g_UAVinfo + 6, R13
        MOVA    SP, R12
        ADDA    #0x2, R12
          CFI FunCall memcpy
        CALLA   #memcpy
//  351 
//  352     ZKHD_Link_MakeFrame( Device_FMU,
//  353                     Device_GCS,
//  354                     MsgID_1_Motor_Info,
//  355                     DataBuff,
//  356                     8,
//  357                     SendBuff,
//  358                     &SendLength
//  359                    );
        MOVA    SP, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+38
        MOVA    SP, R15
        ADDA    #0xe, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+42
        PUSH.W  #0x8
          CFI CFA SP+44
        MOVA    SP, R15
        ADDA    #0xc, R15
        MOV.B   #0x1, R14
        MOV.B   #0x0, R13
        MOV.B   #0x1, R12
          CFI FunCall ZKHD_Link_MakeFrame
        CALLA   #ZKHD_Link_MakeFrame
//  360 //    if(u)
//  361     enQueue(&USB_Send_Queue, SendBuff, SendLength);
        MOV.B   0xa(SP), R14
        MOVA    SP, R13
        ADDA    #0x14, R13
        MOVA    #USB_Send_Queue, R12
          CFI FunCall enQueue
        CALLA   #enQueue
//  362 }
        ADDA    #0x28, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock8
//  363 
//  364 /******************************************************************************
//  365   * 函数名称：UpdateToGCSHardwareInfo
//  366   * 函数描述：更新硬件输出信息到地面站中
//  367   * 输    入：void
//  368   * 输    出：void
//  369   * 返    回：void
//  370   * 备    注：null      
//  371   *
//  372   *
//  373 ******************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  374 void UpdateToGCSHardwareInfo(void)
UpdateToGCSHardwareInfo:
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function UpdateToGCSHardwareInfo
//  375 {
        SUBA    #0x24, SP
          CFI CFA SP+40
//  376     uint8_t DataBuff[13];
//  377     uint8_t SendBuff[20];
//  378     uint8_t SendLength;
//  379     
//  380     DataBuff[0] = g_UAVinfo.Firmware_Ver;//版本信息
        MOVX.B  &g_UAVinfo + 4, 0x2(SP)
//  381     memcpy(DataBuff + 1, g_UAVinfo.NRF_MannagerPtr->Rx_Addr, 5);//发送地址
        MOV.W   #0x5, R14
        MOV.W   #0x0, R15
        MOVA    &g_UAVinfo + 12, R13
        ADDA    #0x6, R13
        MOVA    SP, R12
        ADDA    #0x3, R12
          CFI FunCall memcpy
        CALLA   #memcpy
//  382     memcpy(DataBuff + 1 + 5, g_UAVinfo.NRF_MannagerPtr->Tx_Addr, 5);//发送地址
        MOV.W   #0x5, R14
        MOV.W   #0x0, R15
        MOVA    &g_UAVinfo + 12, R13
        ADDA    #0x1, R13
        MOVA    SP, R12
        ADDA    #0x8, R12
          CFI FunCall memcpy
        CALLA   #memcpy
//  383     DataBuff[11] = g_UAVinfo.Runtime&0xFF;
        MOVX.B  &g_UAVinfo, 0xd(SP)
//  384     DataBuff[12] = g_UAVinfo.Runtime>>8;
        MOVX.W  &g_UAVinfo, R14
        SWPB    R14
        AND.W   #0xff, R14
        MOV.B   R14, 0xe(SP)
//  385 
//  386     ZKHD_Link_MakeFrame( Device_FMU,
//  387                         Device_GCS,
//  388                         MsgID_5_Hardware_Info,
//  389                         DataBuff,
//  390                         13,
//  391                         SendBuff,
//  392                         &SendLength
//  393                        );
        MOVA    SP, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+44
        MOVA    SP, R15
        ADDA    #0x14, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+48
        PUSH.W  #0xd
          CFI CFA SP+50
        MOVA    SP, R15
        ADDA    #0xc, R15
        MOV.B   #0x5, R14
        MOV.B   #0x0, R13
        MOV.B   #0x1, R12
          CFI FunCall ZKHD_Link_MakeFrame
        CALLA   #ZKHD_Link_MakeFrame
//  394     
//  395     enQueue(&USB_Send_Queue, SendBuff, SendLength);
        MOV.B   0xa(SP), R14
        MOVA    SP, R13
        ADDA    #0x1a, R13
        MOVA    #USB_Send_Queue, R12
          CFI FunCall enQueue
        CALLA   #enQueue
//  396 }
        ADDA    #0x2e, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock9
//  397 
//  398 /******************************************************************************
//  399   * 函数名称：UpdateToGCSFreq
//  400   * 函数描述：更新飞控输出NRF24L01频率信息到地面站中
//  401   * 输    入：void
//  402   * 输    出：void
//  403   * 返    回：void
//  404   * 备    注：null      
//  405   *
//  406   *
//  407 ******************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  408 void UpdateToGCSFreq()
UpdateToGCSFreq:
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function UpdateToGCSFreq
//  409 {
        SUBA    #0x16, SP
          CFI CFA SP+26
//  410     uint8_t SendBuff[20];
//  411     uint8_t SendLength;
//  412     
//  413     ZKHD_Link_MakeFrame( Device_FMU,
//  414                     Device_GCS,
//  415                     MsgID_7_Freq,
//  416                     &g_UAVinfo.NRF_MannagerPtr->RC_Frequency,
//  417                     1,
//  418                     SendBuff,
//  419                     &SendLength
//  420                     );
        MOVA    SP, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+30
        MOVA    SP, R15
        ADDA    #0x6, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+34
        PUSH.W  #0x1
          CFI CFA SP+36
        MOVA    &g_UAVinfo + 12, R15
        ADDA    #0xb, R15
        MOV.B   #0x7, R14
        MOV.B   #0x0, R13
        MOV.B   #0x1, R12
          CFI FunCall ZKHD_Link_MakeFrame
        CALLA   #ZKHD_Link_MakeFrame
//  421     
//  422     enQueue(&USB_Send_Queue, SendBuff, SendLength);
        MOV.B   0xa(SP), R14
        MOVA    SP, R13
        ADDA    #0xc, R13
        MOVA    #USB_Send_Queue, R12
          CFI FunCall enQueue
        CALLA   #enQueue
//  423 }
        ADDA    #0x20, SP
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock10
//  424 
//  425 /******************************************************************************
//  426   * 函数名称：UpdateToGCSLine
//  427   * 函数描述：更新曲线绘制信息到地面站中
//  428   * 输    入：int16_t l1:曲线1
//  429               int16_t l2:曲线2
//  430               int16_t l3:曲线3
//  431               int16_t l2:曲线4
//  432               int16_t l3:曲线5
//  433               int16_t l1:曲线6
//  434               int16_t l2:曲线7
//  435               int16_t l3:曲线8
//  436   * 输    出：void
//  437   * 返    回：void
//  438   * 备    注：null      
//  439   *
//  440   *
//  441 ******************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  442 void UpdateToGCSLine(int16_t l1, int16_t l2, int16_t l3, int16_t l4, int16_t l5, int16_t l6, int16_t l7, int16_t l8)
UpdateToGCSLine:
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function UpdateToGCSLine
//  443 {
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        SUBA    #0x30, SP
          CFI CFA SP+84
        MOV.W   R12, R5
        MOV.W   R13, R4
        MOV.W   R14, R7
        MOV.W   R15, R10
        MOV.W   0x54(SP), R11
        MOV.W   0x56(SP), R8
        MOV.W   0x58(SP), R9
        MOV.W   0x5a(SP), R6
//  444     int16_t DataBuff[8];
//  445     uint8_t SendBuff[30];
//  446     uint8_t SendLength;
//  447     
//  448     DataBuff[0] = l1;
        MOV.W   R5, 0x2(SP)
//  449     DataBuff[1] = l2;
        MOV.W   R4, 0x4(SP)
//  450     DataBuff[2] = l3;
        MOV.W   R7, 0x6(SP)
//  451     DataBuff[3] = l4;
        MOV.W   R10, 0x8(SP)
//  452     DataBuff[4] = l5;
        MOV.W   R11, 0xa(SP)
//  453     DataBuff[5] = l6;
        MOV.W   R8, 0xc(SP)
//  454     DataBuff[6] = l7;
        MOV.W   R9, 0xe(SP)
//  455     DataBuff[7] = l8;
        MOV.W   R6, 0x10(SP)
//  456     
//  457 
//  458     ZKHD_Link_MakeFrame( Device_FMU,
//  459                     Device_GCS,
//  460                     MsgID_3_Line_Info,
//  461                     (uint8_t*)DataBuff,
//  462                     16,
//  463                     SendBuff,
//  464                     &SendLength
//  465                     );
        MOVA    SP, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+88
        MOVA    SP, R15
        ADDA    #0x16, R15
        PUSHM.A #0x1, R15
          CFI CFA SP+92
        PUSH.W  #0x10
          CFI CFA SP+94
        MOVA    SP, R15
        ADDA    #0xc, R15
        MOV.B   #0x3, R14
        MOV.B   #0x0, R13
        MOV.B   #0x1, R12
          CFI FunCall ZKHD_Link_MakeFrame
        CALLA   #ZKHD_Link_MakeFrame
//  466     
//  467     enQueue(&USB_Send_Queue, SendBuff, SendLength);
        MOV.B   0xa(SP), R14
        MOVA    SP, R13
        ADDA    #0x1c, R13
        MOVA    #USB_Send_Queue, R12
          CFI FunCall enQueue
        CALLA   #enQueue
//  468 }
        ADDA    #0x3a, SP
          CFI CFA SP+36
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock11
//  469 
//  470 /******************************************************************************
//  471   * 函数名称：UpdateToGCSLine2
//  472   * 函数描述：更新曲线绘制信息到地面站中，此函数适用于山外调试助手
//  473   * 输    入：int16_t l1:曲线1
//  474               int16_t l2:曲线2
//  475               int16_t l3:曲线3
//  476               int16_t l2:曲线4
//  477               int16_t l3:曲线5
//  478               int16_t l1:曲线6
//  479               int16_t l2:曲线7
//  480               int16_t l3:曲线8
//  481   * 输    出：void
//  482   * 返    回：void
//  483   * 备    注：null  
//  484   *
//  485 ******************************************************************************/

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
//  486 void UpdateToGCSLine2(int16_t l1, int16_t l2, int16_t l3, int16_t l4, int16_t l5, int16_t l6, int16_t l7, int16_t l8)
UpdateToGCSLine2:
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function UpdateToGCSLine2
//  487 {
        PUSHM.A #0x8, R11
          CFI R4L Frame(CFA, -36)
          CFI R4H Frame(CFA, -34)
          CFI R5L Frame(CFA, -32)
          CFI R5H Frame(CFA, -30)
          CFI R6L Frame(CFA, -28)
          CFI R6H Frame(CFA, -26)
          CFI R7L Frame(CFA, -24)
          CFI R7H Frame(CFA, -22)
          CFI R8L Frame(CFA, -20)
          CFI R8H Frame(CFA, -18)
          CFI R9L Frame(CFA, -16)
          CFI R9H Frame(CFA, -14)
          CFI R10L Frame(CFA, -12)
          CFI R10H Frame(CFA, -10)
          CFI R11L Frame(CFA, -8)
          CFI R11H Frame(CFA, -6)
          CFI CFA SP+36
        SUBA    #0x2e, SP
          CFI CFA SP+82
        MOV.W   R12, R5
        MOV.W   R13, R4
        MOV.W   R14, R7
        MOV.W   R15, R6
        MOV.W   0x52(SP), R10
        MOV.W   0x54(SP), R11
        MOV.W   0x56(SP), R8
        MOV.W   0x58(SP), R9
//  488     int16_t DataBuff[8];
//  489     uint8_t SendBuff[30];
//  490     
//  491     DataBuff[0] = l1;
        MOV.W   R5, 0(SP)
//  492     DataBuff[1] = l2;
        MOV.W   R4, 0x2(SP)
//  493     DataBuff[2] = l3;
        MOV.W   R7, 0x4(SP)
//  494     DataBuff[3] = l4;
        MOV.W   R6, 0x6(SP)
//  495     DataBuff[4] = l5;
        MOV.W   R10, 0x8(SP)
//  496     DataBuff[5] = l6;
        MOV.W   R11, 0xa(SP)
//  497     DataBuff[6] = l7;
        MOV.W   R8, 0xc(SP)
//  498     DataBuff[7] = l8;
        MOV.W   R9, 0xe(SP)
//  499     
//  500     SendBuff[0] = 03;
        MOV.B   #0x3, 0x10(SP)
//  501     SendBuff[1] = 0xFC;
        MOV.B   #0xfc, 0x11(SP)
//  502     SendBuff[18] = 0xFC;
        MOV.B   #0xfc, 0x22(SP)
//  503     SendBuff[19] = 0x03;
        MOV.B   #0x3, 0x23(SP)
//  504     memcpy(SendBuff + 2,(uint8_t*)DataBuff, 16);
        MOV.W   #0x10, R14
        MOV.W   #0x0, R15
        MOVA    SP, R13
        MOVA    SP, R12
        ADDA    #0x12, R12
          CFI FunCall memcpy
        CALLA   #memcpy
//  505     enQueue(&USB_Send_Queue, SendBuff, 20);
        MOV.B   #0x14, R14
        MOVA    SP, R13
        ADDA    #0x10, R13
        MOVA    #USB_Send_Queue, R12
          CFI FunCall enQueue
        CALLA   #enQueue
//  506 }
        ADDA    #0x2e, SP
          CFI CFA SP+36
        POPM.A  #0x8, R11
          CFI R10H SameValue
          CFI R11H SameValue
          CFI R4H SameValue
          CFI R5H SameValue
          CFI R6H SameValue
          CFI R7H SameValue
          CFI R8H SameValue
          CFI R9H SameValue
          CFI R10L SameValue
          CFI R11L SameValue
          CFI R4L SameValue
          CFI R5L SameValue
          CFI R6L SameValue
          CFI R7L SameValue
          CFI R8L SameValue
          CFI R9L SameValue
          CFI CFA SP+4
        RETA
          CFI EndBlock cfiBlock12

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
//  507 
//  508 /******************* (C) 版权所有 2018 北京中科浩电科技有限公司 *******************/
// 
// 1 594 bytes in segment CODE
//    42 bytes in segment DATA20_Z
// 
// 1 594 bytes of CODE memory
//    42 bytes of DATA memory
//
//Errors: none
//Warnings: none
