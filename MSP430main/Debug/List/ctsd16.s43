///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.12.1.987/W32 for MSP430          20/Nov/2018  15:34:06
// Copyright 1996-2018 IAR Systems AB.
// PC-locked license - IAR Embedded Workbench for Texas Instruments MSP430
//
//    __rt_version  =  3
//    __double_size =  32
//    __reg_r4      =  free
//    __reg_r5      =  free
//    __pic         =  no
//    __core        =  430X
//    __data_model  =  large
//    __code_model  =  large
//    Source file   =  
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\driverlib\ctsd16.c
//    Command line  =  
//        -f C:\Users\颜子楠\AppData\Local\Temp\EW1948.tmp
//        (D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\driverlib\ctsd16.c
//        -D DEBUG -D RAM_VECTOR -lA
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Debug\List
//        -o
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Debug\Obj
//        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
//        -D__MSP430F5529__ -e --double=32 --dlib_config
//        D:\IAR\430\lib\dlib\dl430xllff.h -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Drivers\inc\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Drivers\src\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HardWare\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HardWare\delay\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HardWare\nrf24l01\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\System\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\System\inc\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\System\src\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\User\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\User\USER\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HardWare\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\MATH\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HAL\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\src\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Communication\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Control\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\DataBase\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\GCS\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\MidWare\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\driverlib\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\driverlib\inc\
//        --core=430X --data_model=large -On --multiplier=32
//        --hw_workaround=CPU40 --hw_workaround=nop_after_lpm
//        --code_model=large)
//    Locale        =  Chinese (Simplified)_CHN.936
//    List file     =  
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Debug\List\ctsd16.s43
//
///////////////////////////////////////////////////////////////////////////////

        NAME ctsd16

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__code_model", "large"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "large"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\driverlib\ctsd16.c
//    1 /* --COPYRIGHT--,BSD
//    2  * Copyright (c) 2017, Texas Instruments Incorporated
//    3  * All rights reserved.
//    4  *
//    5  * Redistribution and use in source and binary forms, with or without
//    6  * modification, are permitted provided that the following conditions
//    7  * are met:
//    8  *
//    9  * *  Redistributions of source code must retain the above copyright
//   10  *    notice, this list of conditions and the following disclaimer.
//   11  *
//   12  * *  Redistributions in binary form must reproduce the above copyright
//   13  *    notice, this list of conditions and the following disclaimer in the
//   14  *    documentation and/or other materials provided with the distribution.
//   15  *
//   16  * *  Neither the name of Texas Instruments Incorporated nor the names of
//   17  *    its contributors may be used to endorse or promote products derived
//   18  *    from this software without specific prior written permission.
//   19  *
//   20  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//   21  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
//   22  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//   23  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
//   24  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
//   25  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
//   26  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
//   27  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
//   28  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
//   29  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//   30  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   31  * --/COPYRIGHT--*/
//   32 //*****************************************************************************
//   33 //
//   34 // ctsd16.c - Driver for the ctsd16 Module.
//   35 //
//   36 //*****************************************************************************
//   37 
//   38 //*****************************************************************************
//   39 //
//   40 //! \addtogroup ctsd16_api ctsd16
//   41 //! @{
//   42 //
//   43 //*****************************************************************************
//   44 
//   45 #include "inc/hw_memmap.h"
//   46 
//   47 #ifdef __MSP430_HAS_CTSD16__
//   48 #include "ctsd16.h"
//   49 
//   50 #include <assert.h>
//   51 
//   52 void CTSD16_init(uint16_t baseAddress, uint16_t chargePumpBurstRequest, 
//   53     uint8_t referenceSelect)
//   54 {
//   55     // Reset all interrupts and flags
//   56     HWREG16(baseAddress + OFS_CTSD16IE)   &= 0x0000; //Reset ALL interrupt enables
//   57     HWREG16(baseAddress + OFS_CTSD16IFG)  &= 0x0000; //Reset ALL interrupt flags
//   58 
//   59     // Configure CTSD16
//   60     HWREG16(baseAddress + OFS_CTSD16CTL) &= ~(CTSD16RRIBURST | CTSD16OFFG |
//   61         CTSD16REFS);
//   62 
//   63     HWREG16(baseAddress + OFS_CTSD16CTL) |= chargePumpBurstRequest | referenceSelect;
//   64 
//   65     return;
//   66 }
//   67 
//   68 void CTSD16_initConverter(uint16_t baseAddress, uint8_t converter, 
//   69     uint16_t conversionMode, uint8_t inputChannel)
//   70 {
//   71     uint16_t address;
//   72     address = baseAddress + (OFS_CTSD16CCTL0 + (converter * 0x06));
//   73 
//   74     // Clearing previous settings for configuration
//   75     HWREG16(address) &= ~(CTSD16SC | CTSD16SNGL);
//   76 
//   77     HWREG16(address) |= conversionMode;
//   78 
//   79     address += 0x2;
//   80 
//   81     HWREG16(address) &= ~(CTSD16INCH4 | CTSD16INCH3 | CTSD16INCH2 |
//   82             CTSD16INCH1 | CTSD16INCH0);
//   83 
//   84     HWREG16(address) |= inputChannel;
//   85 }
//   86 
//   87 void CTSD16_initConverterAdvanced(uint16_t baseAddress,
//   88     CTSD16_initConverterAdvancedParam *param)
//   89 {
//   90     uint16_t address;
//   91 
//   92     // Getting correct CTSD16CCTLx register
//   93     address = baseAddress + (OFS_CTSD16CCTL0 + (param->converter * 0x06));
//   94 
//   95     // Clearing previous settings for configuration
//   96     HWREG16(address) &= ~(CTSD16SC | CTSD16SNGL | CTSD16GRP | CTSD16OSR__32 |
//   97         CTSD16DF);
//   98 
//   99     HWREG16(address) |= (param->groupEnable | param->conversionMode | param->oversampleRatio | param->dataFormat);
//  100 
//  101     // Getting correct CTSD16INCTLx register
//  102     address += 0x2;
//  103 
//  104     HWREG16(address) &= ~(CTSD16RRI | CTSD16INTDLY | CTSD16GAIN2 |
//  105         CTSD16GAIN1 | CTSD16GAIN0 | CTSD16INCH4 | CTSD16INCH3 | CTSD16INCH2 |
//  106         CTSD16INCH1 | CTSD16INCH0);
//  107 
//  108     HWREG16(address) |= (param->railToRailInput | param->interruptDelay |
//  109         param->gain | param->inputChannel);
//  110 
//  111 }
//  112 
//  113 void CTSD16_startConverterConversion(uint16_t baseAddress,
//  114         uint8_t converter)
//  115 {
//  116     uint16_t address;
//  117 
//  118     address = baseAddress + (OFS_CTSD16CCTL0 + (converter * 0x06));
//  119 
//  120     // Setting CTSD16SC bit to start conversion
//  121     HWREG16(address) |= CTSD16SC;
//  122 }
//  123 
//  124 void CTSD16_stopConverterConversion(uint16_t baseAddress,
//  125         uint8_t converter)
//  126 {
//  127     uint16_t address;
//  128 
//  129     address = baseAddress + (OFS_CTSD16CCTL0 + (converter * 0x06));
//  130 
//  131     // Setting CTSD16SC bit to start conversion
//  132     HWREG16(address) &= ~(CTSD16SC);
//  133 }
//  134 
//  135 void CTSD16_setConverterDataFormat(uint16_t baseAddress,
//  136         uint8_t converter,
//  137         uint8_t dataFormat)
//  138 {
//  139     uint16_t address;
//  140 
//  141     address = baseAddress + (OFS_CTSD16CCTL0 + (converter * 0x06));
//  142 
//  143     // Clearing previous settings for configuration
//  144     HWREG8(address) &= ~CTSD16DF;
//  145 
//  146     HWREG8(address) |= dataFormat;
//  147 }
//  148 
//  149 void CTSD16_setInputChannel(uint16_t baseAddress,
//  150         uint8_t converter,
//  151         uint8_t inputChannel)
//  152 {
//  153     uint16_t address;
//  154 
//  155     address = baseAddress + (OFS_CTSD16INCTL0 + (converter * 0x06));
//  156 
//  157     // Clear previous settings
//  158     HWREG16(address) &= ~(CTSD16INCH4 | CTSD16INCH3 | CTSD16INCH2 |
//  159             CTSD16INCH1 | CTSD16INCH0);
//  160 
//  161     HWREG16(address) |= inputChannel;
//  162 }
//  163 
//  164 void CTSD16_setRailToRailInput(uint16_t baseAddress,
//  165         uint8_t converter,
//  166         uint16_t railToRailInput)
//  167 {
//  168     uint16_t address;
//  169 
//  170     address = baseAddress + (OFS_CTSD16INCTL0 + (converter * 0x06));
//  171 
//  172     // Clear previous settings
//  173     HWREG16(address) &= ~CTSD16RRI;
//  174 
//  175     HWREG16(address) |= railToRailInput;
//  176 }
//  177 
//  178 void CTSD16_setInterruptDelay(uint16_t baseAddress,
//  179         uint8_t converter,
//  180         uint16_t interruptDelay)
//  181 {
//  182     uint16_t address;
//  183 
//  184     address = baseAddress + (OFS_CTSD16INCTL0 + (converter * 0x06));
//  185 
//  186     // Clear previous settings
//  187     HWREG16(address) &= ~CTSD16INTDLY;
//  188 
//  189     HWREG16(address) |= interruptDelay;
//  190 
//  191 }
//  192 
//  193 void CTSD16_setOversampling(uint16_t baseAddress,
//  194         uint8_t converter,
//  195         uint16_t oversampleRatio)
//  196 {
//  197     uint16_t address;
//  198 
//  199     address = baseAddress + (OFS_CTSD16CCTL0 + (converter * 0x06));
//  200 
//  201     // Setting CTSD16SC bit to start conversion
//  202     HWREG16(address) |= oversampleRatio;
//  203 }
//  204 
//  205 void CTSD16_setGain(uint16_t baseAddress,
//  206         uint8_t converter,
//  207         uint8_t gain)
//  208 {
//  209     uint16_t address;
//  210 
//  211     address = baseAddress + (OFS_CTSD16INCTL0 + (converter * 0x06));
//  212 
//  213     // Clear previous settings
//  214     HWREG16(address) &= ~(CTSD16GAIN2 | CTSD16GAIN1 | CTSD16GAIN0);
//  215 
//  216     HWREG16(address) |= gain;
//  217 }
//  218 
//  219 uint32_t CTSD16_getResults(uint16_t baseAddress,
//  220                             uint8_t converter)
//  221 {
//  222     volatile uint16_t OSR;
//  223 
//  224     uint16_t address = baseAddress + (OFS_CTSD16MEM0 + (converter * 0x02));
//  225 
//  226     // Get high word result
//  227     HWREG16(baseAddress + (OFS_CTSD16CCTL0 + (converter * 0x02))) &= ~(CTSD16LSBACC);
//  228     uint32_t highResult = (uint32_t)HWREG16(address);
//  229 
//  230     // Get low word result
//  231     HWREG16(baseAddress + (OFS_CTSD16CCTL0 + (converter * 0x02))) |= CTSD16LSBACC;
//  232     uint16_t lowResult = HWREG16(address);
//  233     HWREG16(baseAddress + (OFS_CTSD16CCTL0 + (converter * 0x02))) &= ~(CTSD16LSBACC);
//  234 
//  235     // Determine the OSR and combine the high and low result words as appropriate
//  236     OSR = HWREG16(baseAddress + (OFS_CTSD16CCTL0 + (converter * 0x02)))  & (CTSD16OSR0 | CTSD16OSR1);
//  237 
//  238     if(OSR == CTSD16_OVERSAMPLE_256)
//  239     {
//  240         return (highResult << 8) | lowResult;
//  241     }
//  242     else if(OSR == CTSD16_OVERSAMPLE_128)
//  243     {
//  244         return (highResult << 5) | lowResult;
//  245     }
//  246     else if(OSR == CTSD16_OVERSAMPLE_64)
//  247     {
//  248         return (highResult << 2) | lowResult;
//  249     }
//  250     else        // OSR = CTSD16_OVERSAMPLE_32
//  251     {
//  252         return (highResult);
//  253     }
//  254 }
//  255 
//  256 uint16_t CTSD16_getHighWordResults(uint16_t baseAddress,
//  257                                     uint8_t converter)
//  258 {
//  259     // Calculate address of MEM results
//  260     uint16_t address = baseAddress + (OFS_CTSD16MEM0 + (converter * 0x02));
//  261 
//  262     // Get high word result
//  263     HWREG16(baseAddress + (OFS_CTSD16CCTL0 + (converter * 0x02))) &= ~(CTSD16LSBACC);
//  264     uint16_t highResult = HWREG16(address);
//  265 
//  266     return(highResult);
//  267 }
//  268 
//  269 uint16_t CTSD16_isRailToRailInputReady(uint16_t baseAddress)
//  270 {
//  271     return HWREG16(baseAddress + OFS_CTSD16CTL) & CTSD16RRIRDY;
//  272 }
//  273 
//  274 void CTSD16_enableInterrupt (uint16_t baseAddress,
//  275     uint8_t converter,
//  276     uint16_t mask)
//  277 {
//  278     //Enable Interrupt
//  279     HWREG16(baseAddress + OFS_CTSD16IE) |= (mask << converter);
//  280 
//  281 }
//  282 
//  283 void CTSD16_disableInterrupt (uint16_t baseAddress,
//  284     uint8_t converter,
//  285     uint16_t mask)
//  286 {
//  287     //Enable Interrupt
//  288     HWREG16(baseAddress + OFS_CTSD16IE) &= ~(mask << converter);
//  289 
//  290 }
//  291 
//  292 void CTSD16_clearInterrupt (uint16_t baseAddress,
//  293     uint8_t converter,
//  294     uint16_t mask)
//  295 {
//  296     HWREG16(baseAddress + OFS_CTSD16IFG) &= ~(mask << converter);
//  297 }
//  298 
//  299 uint16_t CTSD16_getInterruptStatus (uint16_t baseAddress,
//  300     uint8_t converter,
//  301     uint16_t mask)
//  302 {
//  303     return ( HWREG16(baseAddress + OFS_CTSD16IFG) & (mask << converter) );
//  304 }
//  305 
//  306 #endif
//  307 //*****************************************************************************
//  308 //
//  309 //! Close the doxygen group for ctsd16_api
//  310 //! @}
//  311 //
//  312 //*****************************************************************************
// 
//
// 
//
//
//Errors: none
//Warnings: none
