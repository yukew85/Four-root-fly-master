///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V7.12.1.987/W32 for MSP430          20/Nov/2018  15:34:11
// Copyright 1996-2018 IAR Systems AB.
// PC-locked license - IAR Embedded Workbench for Texas Instruments MSP430
//
//    __rt_version  =  3
//    __double_size =  32
//    __reg_r4      =  free
//    __reg_r5      =  free
//    __pic         =  no
//    __core        =  430X
//    __data_model  =  large
//    __code_model  =  large
//    Source file   =  
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\driverlib\rtc_c.c
//    Command line  =  
//        -f C:\Users\颜子楠\AppData\Local\Temp\EW2E10.tmp
//        (D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\driverlib\rtc_c.c
//        -D DEBUG -D RAM_VECTOR -lA
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Debug\List
//        -o
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Debug\Obj
//        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
//        -D__MSP430F5529__ -e --double=32 --dlib_config
//        D:\IAR\430\lib\dlib\dl430xllff.h -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Drivers\inc\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Drivers\src\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HardWare\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HardWare\delay\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HardWare\nrf24l01\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\System\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\System\inc\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\System\src\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\User\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\User\USER\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HardWare\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\MATH\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\HAL\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\src\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Communication\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Control\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\DataBase\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\GCS\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\MidWare\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\driverlib\
//        -I
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\driverlib\inc\
//        --core=430X --data_model=large -On --multiplier=32
//        --hw_workaround=CPU40 --hw_workaround=nop_after_lpm
//        --code_model=large)
//    Locale        =  Chinese (Simplified)_CHN.936
//    List file     =  
//        D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\Debug\List\rtc_c.s43
//
///////////////////////////////////////////////////////////////////////////////

        NAME rtc_c

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__code_model", "large"
        RTMODEL "__core", "430X"
        RTMODEL "__data_model", "large"
        RTMODEL "__double_size", "32"
        RTMODEL "__pic", "no"
        RTMODEL "__reg_r4", "free"
        RTMODEL "__reg_r5", "free"
        RTMODEL "__rt_version", "3"

        RSEG CSTACK:DATA:SORT:NOROOT(0)

        EXTERN ?longjmp_r4
        EXTERN ?longjmp_r5
        EXTERN ?setjmp_r4
        EXTERN ?setjmp_r5

        PUBWEAK ?setjmp_save_r4
        PUBWEAK ?setjmp_save_r5

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
?setjmp_save_r4:
        REQUIRE ?setjmp_r4
        REQUIRE ?longjmp_r4

        RSEG `CODE`:CODE:REORDER:NOROOT(1)
?setjmp_save_r5:
        REQUIRE ?setjmp_r5
        REQUIRE ?longjmp_r5

        END
// D:\F150-T401\F150-T401_Experiment_Code\研发修改目录\附件目录\2.源码\1.飞控源码\driverlib\rtc_c.c
//    1 /* --COPYRIGHT--,BSD
//    2  * Copyright (c) 2017, Texas Instruments Incorporated
//    3  * All rights reserved.
//    4  *
//    5  * Redistribution and use in source and binary forms, with or without
//    6  * modification, are permitted provided that the following conditions
//    7  * are met:
//    8  *
//    9  * *  Redistributions of source code must retain the above copyright
//   10  *    notice, this list of conditions and the following disclaimer.
//   11  *
//   12  * *  Redistributions in binary form must reproduce the above copyright
//   13  *    notice, this list of conditions and the following disclaimer in the
//   14  *    documentation and/or other materials provided with the distribution.
//   15  *
//   16  * *  Neither the name of Texas Instruments Incorporated nor the names of
//   17  *    its contributors may be used to endorse or promote products derived
//   18  *    from this software without specific prior written permission.
//   19  *
//   20  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//   21  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
//   22  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//   23  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
//   24  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
//   25  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
//   26  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
//   27  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
//   28  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
//   29  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//   30  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//   31  * --/COPYRIGHT--*/
//   32 //*****************************************************************************
//   33 //
//   34 // rtc_c.c - Driver for the rtc_c Module.
//   35 //
//   36 //*****************************************************************************
//   37 
//   38 //*****************************************************************************
//   39 //
//   40 //! \addtogroup rtc_c_api rtc_c
//   41 //! @{
//   42 //
//   43 //*****************************************************************************
//   44 
//   45 #include "inc/hw_memmap.h"
//   46 
//   47 #if defined(__MSP430_HAS_RTC_C__) || defined(__MSP430_HAS_RTC_CE__)
//   48 #include "rtc_c.h"
//   49 
//   50 #include <assert.h>
//   51 
//   52 void RTC_C_startClock (uint16_t baseAddress)
//   53 {
//   54     HWREG8(baseAddress + OFS_RTCCTL0_H) = RTCKEY_H;
//   55     HWREG8(baseAddress + OFS_RTCCTL13_L) &= ~(RTCHOLD);
//   56     HWREG8(baseAddress + OFS_RTCCTL0_H) = 0x00;
//   57 }
//   58 
//   59 void RTC_C_holdClock (uint16_t baseAddress)
//   60 {
//   61     HWREG8(baseAddress + OFS_RTCCTL0_H) = RTCKEY_H;
//   62     HWREG8(baseAddress + OFS_RTCCTL13_L) |= RTCHOLD;
//   63     HWREG8(baseAddress + OFS_RTCCTL0_H) = 0x00;
//   64 }
//   65 
//   66 void RTC_C_setCalibrationFrequency (uint16_t baseAddress,
//   67     uint16_t frequencySelect)
//   68 {
//   69     HWREG8(baseAddress + OFS_RTCCTL0_H) = RTCKEY_H;
//   70     HWREG16(baseAddress + OFS_RTCCTL13) &= ~(RTCCALF_3);
//   71     HWREG16(baseAddress + OFS_RTCCTL13) |= frequencySelect;
//   72     HWREG8(baseAddress + OFS_RTCCTL0_H) = 0x00;
//   73 }
//   74 
//   75 void RTC_C_setCalibrationData (uint16_t baseAddress,
//   76     uint8_t offsetDirection,
//   77     uint8_t offsetValue)
//   78 {
//   79     HWREG8(baseAddress + OFS_RTCCTL0_H) = RTCKEY_H;
//   80     HWREG16(baseAddress + OFS_RTCOCAL) = offsetValue + offsetDirection;
//   81     HWREG8(baseAddress + OFS_RTCCTL0_H) = 0x00;
//   82 }
//   83 
//   84 void RTC_C_initCounter (uint16_t baseAddress,
//   85     uint16_t clockSelect,
//   86     uint16_t counterSizeSelect)
//   87 {
//   88     HWREG8(baseAddress + OFS_RTCCTL0_H) = RTCKEY_H;
//   89 
//   90     HWREG8(baseAddress + OFS_RTCCTL13) |= RTCHOLD;
//   91     HWREG8(baseAddress + OFS_RTCCTL13) &= ~(RTCMODE);
//   92 
//   93     HWREG16(baseAddress + OFS_RTCCTL13) &= ~(RTCSSEL_3 | RTCTEV_3 );
//   94     HWREG16(baseAddress + OFS_RTCCTL13) |= clockSelect + counterSizeSelect;
//   95 
//   96     HWREG8(baseAddress + OFS_RTCCTL0_H) = 0x00;
//   97 }
//   98 
//   99 bool RTC_C_setTemperatureCompensation(uint16_t baseAddress,
//  100     uint16_t offsetDirection,
//  101     uint8_t offsetValue)
//  102 {
//  103 
//  104     while(!(HWREG8(baseAddress + OFS_RTCTCMP_H) & RTCTCRDY_H));
//  105 
//  106     HWREG16(baseAddress + OFS_RTCTCMP) = offsetValue + offsetDirection;
//  107 
//  108     if(HWREG8(baseAddress + OFS_RTCTCMP_H) & RTCTCOK_H) {
//  109         return STATUS_SUCCESS;
//  110     } else {
//  111         return STATUS_FAIL;
//  112     }
//  113 }
//  114 
//  115 void RTC_C_initCalendar (uint16_t baseAddress,
//  116     Calendar *CalendarTime,
//  117     uint16_t formatSelect)
//  118 {
//  119 
//  120     HWREG8(baseAddress + OFS_RTCCTL0_H) = RTCKEY_H;
//  121 
//  122     HWREG8(baseAddress + OFS_RTCCTL13_L) |= RTCHOLD;
//  123 
//  124     HWREG16(baseAddress + OFS_RTCCTL13_L) &= ~(RTCBCD);
//  125     HWREG16(baseAddress + OFS_RTCCTL13_L) |= formatSelect;
//  126 
//  127     HWREG8(baseAddress + OFS_RTCTIM0_L) = CalendarTime->Seconds;
//  128     HWREG8(baseAddress + OFS_RTCTIM0_H) = CalendarTime->Minutes;
//  129     HWREG8(baseAddress + OFS_RTCTIM1_L) = CalendarTime->Hours;
//  130     HWREG8(baseAddress + OFS_RTCTIM1_H) = CalendarTime->DayOfWeek;
//  131     HWREG8(baseAddress + OFS_RTCDATE_L) = CalendarTime->DayOfMonth;
//  132     HWREG8(baseAddress + OFS_RTCDATE_H) = CalendarTime->Month;
//  133     HWREG16(baseAddress + OFS_RTCYEAR) = CalendarTime->Year;
//  134 
//  135     HWREG8(baseAddress + OFS_RTCCTL0_H) = 0x00;
//  136 }
//  137 
//  138 Calendar RTC_C_getCalendarTime (uint16_t baseAddress)
//  139 {
//  140     Calendar tempCal;
//  141 
//  142     while ( !(HWREG8(baseAddress + OFS_RTCCTL13_L) & RTCRDY) ) ;
//  143 
//  144     tempCal.Seconds    = HWREG8(baseAddress + OFS_RTCTIM0_L);
//  145     tempCal.Minutes    = HWREG8(baseAddress + OFS_RTCTIM0_H);
//  146     tempCal.Hours      = HWREG8(baseAddress + OFS_RTCTIM1_L);
//  147     tempCal.DayOfWeek  = HWREG8(baseAddress + OFS_RTCTIM1_H);
//  148     tempCal.DayOfMonth = HWREG8(baseAddress + OFS_RTCDATE_L);
//  149     tempCal.Month      = HWREG8(baseAddress + OFS_RTCDATE_H);
//  150     tempCal.Year       = HWREG16(baseAddress + OFS_RTCYEAR);
//  151 
//  152     return ( tempCal) ;
//  153 }
//  154 
//  155 void RTC_C_configureCalendarAlarm(uint16_t baseAddress,
//  156     RTC_C_configureCalendarAlarmParam *param)
//  157 {
//  158     //Each of these is XORed with 0x80 to turn on if an integer is passed,
//  159     //or turn OFF if RTC_C_ALARM_OFF (0x80) is passed.
//  160     HWREG8(baseAddress + OFS_RTCAMINHR_L) = (param->minutesAlarm ^ 0x80);
//  161     HWREG8(baseAddress + OFS_RTCAMINHR_H) = (param->hoursAlarm ^ 0x80);
//  162     HWREG8(baseAddress + OFS_RTCADOWDAY_L) = (param->dayOfWeekAlarm ^ 0x80);
//  163     HWREG8(baseAddress + OFS_RTCADOWDAY_H) = (param->dayOfMonthAlarm ^ 0x80);
//  164 }
//  165 void RTC_C_setCalendarEvent (uint16_t baseAddress,
//  166     uint16_t eventSelect)
//  167 {
//  168     HWREG8(baseAddress + OFS_RTCCTL0_H) = RTCKEY_H;
//  169     HWREG8(baseAddress + OFS_RTCCTL13_L) &= ~(RTCTEV_3); //Reset bits
//  170     HWREG8(baseAddress + OFS_RTCCTL13_L) |= eventSelect;
//  171     HWREG8(baseAddress + OFS_RTCCTL0_H) = 0x00;
//  172 }
//  173 
//  174 uint32_t RTC_C_getCounterValue (uint16_t baseAddress)
//  175 {
//  176     if ( (HWREG8(baseAddress + OFS_RTCCTL13) & RTCHOLD)
//  177          || (HWREG8(baseAddress + OFS_RTCPS1CTL) & RT1PSHOLD) ){
//  178         return ( 0) ;
//  179     }
//  180 
//  181     uint32_t counterValue_L = HWREG16(baseAddress + OFS_RTCTIM0);
//  182     uint32_t counterValue_H = HWREG16(baseAddress + OFS_RTCTIM1);
//  183     return ( (counterValue_H << 16) + counterValue_L );
//  184 }
//  185 
//  186 void RTC_C_setCounterValue (uint16_t baseAddress,
//  187     uint32_t counterValue)
//  188 {
//  189     uint16_t mode = HWREG16(baseAddress + OFS_RTCCTL13) & RTCTEV_3;
//  190 
//  191     if(mode == RTC_C_COUNTERSIZE_8BIT && counterValue > UINT8_MAX)
//  192         counterValue = UINT8_MAX;
//  193     else if(mode == RTC_C_COUNTERSIZE_16BIT && counterValue > UINT16_MAX)
//  194         counterValue = UINT16_MAX;
//  195     else if(mode == RTC_C_COUNTERSIZE_24BIT && counterValue > 0xFFFFFF)
//  196         counterValue = 0xFFFFFF;
//  197 
//  198     HWREG16(baseAddress + OFS_RTCTIM0) = counterValue;
//  199     HWREG16(baseAddress + OFS_RTCTIM1) = ( counterValue >> 16 );
//  200 }
//  201 
//  202 void RTC_C_initCounterPrescale (uint16_t baseAddress,
//  203     uint8_t prescaleSelect,
//  204     uint16_t prescaleClockSelect,
//  205     uint16_t prescaleDivider)
//  206 {
//  207     HWREG8(baseAddress + OFS_RTCCTL0_H) = RTCKEY_H;
//  208 
//  209     //Reset bits and set clock select
//  210     HWREG16(baseAddress + OFS_RTCPS0CTL + prescaleSelect) =
//  211         prescaleClockSelect + prescaleDivider;
//  212 
//  213     HWREG8(baseAddress + OFS_RTCCTL0_H) = 0x00;
//  214 }
//  215 
//  216 void RTC_C_holdCounterPrescale (uint16_t baseAddress,
//  217     uint8_t prescaleSelect)
//  218 {
//  219     HWREG8(baseAddress + OFS_RTCPS0CTL_H + prescaleSelect) |= RT0PSHOLD_H;
//  220 }
//  221 
//  222 void RTC_C_startCounterPrescale (uint16_t baseAddress,
//  223     uint8_t prescaleSelect)
//  224 {
//  225     HWREG8(baseAddress + OFS_RTCPS0CTL_H + prescaleSelect) &= ~(RT0PSHOLD_H);
//  226 }
//  227 
//  228 void RTC_C_definePrescaleEvent (uint16_t baseAddress,
//  229     uint8_t prescaleSelect,
//  230     uint8_t prescaleEventDivider)
//  231 {
//  232     HWREG8(baseAddress + OFS_RTCPS0CTL_L + prescaleSelect) &= ~(RT0IP_7);
//  233     HWREG8(baseAddress + OFS_RTCPS0CTL_L +
//  234         prescaleSelect) |= prescaleEventDivider;
//  235 }
//  236 
//  237 uint8_t RTC_C_getPrescaleValue (uint16_t baseAddress,
//  238     uint8_t prescaleSelect)
//  239 {
//  240     if (RTC_C_PRESCALE_0 == prescaleSelect){
//  241         return ( HWREG8(baseAddress + OFS_RTCPS_L) );
//  242     } else if (RTC_C_PRESCALE_1 == prescaleSelect){
//  243         return ( HWREG8(baseAddress + OFS_RTCPS_H) );
//  244     } else   {
//  245         return ( 0) ;
//  246     }
//  247 }
//  248 
//  249 void RTC_C_setPrescaleValue(uint16_t baseAddress,
//  250     uint8_t prescaleSelect,
//  251     uint8_t prescaleCounterValue)
//  252 {
//  253     HWREG8(baseAddress + OFS_RTCCTL0_H) = RTCKEY_H;
//  254     if (RTC_C_PRESCALE_0 == prescaleSelect){
//  255         HWREG8(baseAddress + OFS_RTCPS_L) = prescaleCounterValue;
//  256     } else if (RTC_C_PRESCALE_1 == prescaleSelect){
//  257         HWREG8(baseAddress + OFS_RTCPS_H) = prescaleCounterValue;
//  258     }
//  259     HWREG8(baseAddress + OFS_RTCCTL0_H) = 0x00;
//  260 }
//  261 
//  262 void RTC_C_enableInterrupt (uint16_t baseAddress,
//  263     uint8_t interruptMask)
//  264 {
//  265     if ( interruptMask & (RTCOFIE + RTCTEVIE + RTCAIE + RTCRDYIE) ){
//  266         HWREG8(baseAddress + OFS_RTCCTL0_H) = RTCKEY_H;
//  267         HWREG8(baseAddress + OFS_RTCCTL0_L) |=
//  268             (interruptMask & (RTCOFIE + RTCTEVIE + RTCAIE + RTCRDYIE));
//  269         HWREG8(baseAddress + OFS_RTCCTL0_H) = 0x00;
//  270     }
//  271 
//  272     if (interruptMask & RTC_C_PRESCALE_TIMER0_INTERRUPT){
//  273         HWREG8(baseAddress + OFS_RTCPS0CTL_L) |= RT0PSIE;
//  274     }
//  275 
//  276     if (interruptMask & RTC_C_PRESCALE_TIMER1_INTERRUPT){
//  277         HWREG8(baseAddress + OFS_RTCPS1CTL_L) |= RT1PSIE;
//  278     }
//  279 }
//  280 
//  281 void RTC_C_disableInterrupt (uint16_t baseAddress,
//  282     uint8_t interruptMask)
//  283 {
//  284 
//  285     if ( interruptMask & (RTCOFIE + RTCTEVIE + RTCAIE + RTCRDYIE) ){
//  286         HWREG8(baseAddress + OFS_RTCCTL0_H) = RTCKEY_H;
//  287         HWREG8(baseAddress + OFS_RTCCTL0_L) &=
//  288             ~(interruptMask & (RTCOFIE + RTCTEVIE + RTCAIE + RTCRDYIE));
//  289         HWREG8(baseAddress + OFS_RTCCTL0_H) = 0x00;
//  290     }
//  291 
//  292     if (interruptMask & RTC_C_PRESCALE_TIMER0_INTERRUPT){
//  293         HWREG8(baseAddress + OFS_RTCPS0CTL_L) &= ~(RT0PSIE);
//  294     }
//  295 
//  296     if (interruptMask & RTC_C_PRESCALE_TIMER1_INTERRUPT){
//  297         HWREG8(baseAddress + OFS_RTCPS1CTL_L) &= ~(RT1PSIE);
//  298     }
//  299 }
//  300 
//  301 uint8_t RTC_C_getInterruptStatus (uint16_t baseAddress,
//  302     uint8_t interruptFlagMask)
//  303 {
//  304     uint8_t tempInterruptFlagMask = 0x0000;
//  305 
//  306     tempInterruptFlagMask |= (HWREG8(baseAddress + OFS_RTCCTL0_L)
//  307                               & ((interruptFlagMask >> 4)
//  308                                  & (RTCOFIFG +
//  309                                     RTCTEVIFG +
//  310                                     RTCAIFG +
//  311                                     RTCRDYIFG)));
//  312 
//  313     tempInterruptFlagMask = tempInterruptFlagMask << 4;
//  314 
//  315     if (interruptFlagMask & RTC_C_PRESCALE_TIMER0_INTERRUPT){
//  316         if ( HWREG8(baseAddress + OFS_RTCPS0CTL_L) & RT0PSIFG){
//  317             tempInterruptFlagMask |= RTC_C_PRESCALE_TIMER0_INTERRUPT;
//  318         }
//  319     }
//  320 
//  321     if (interruptFlagMask & RTC_C_PRESCALE_TIMER1_INTERRUPT){
//  322         if ( HWREG8(baseAddress + OFS_RTCPS1CTL_L) & RT1PSIFG){
//  323             tempInterruptFlagMask |= RTC_C_PRESCALE_TIMER1_INTERRUPT;
//  324         }
//  325     }
//  326 
//  327     return ( tempInterruptFlagMask) ;
//  328 }
//  329 
//  330 void RTC_C_clearInterrupt (uint16_t baseAddress,
//  331     uint8_t interruptFlagMask)
//  332 {
//  333 
//  334     if ( interruptFlagMask & (RTC_C_TIME_EVENT_INTERRUPT +
//  335                               RTC_C_CLOCK_ALARM_INTERRUPT +
//  336                               RTC_C_CLOCK_READ_READY_INTERRUPT +
//  337                               RTC_C_OSCILLATOR_FAULT_INTERRUPT) ){
//  338         HWREG8(baseAddress + OFS_RTCCTL0_H) = RTCKEY_H;
//  339         HWREG8(baseAddress + OFS_RTCCTL0_L) &=
//  340             ~((interruptFlagMask>>4) & (RTCOFIFG +
//  341                                         RTCTEVIFG +
//  342                                         RTCAIFG +
//  343                                         RTCRDYIFG));
//  344         HWREG8(baseAddress + OFS_RTCCTL0_H) = 0x00;
//  345     }
//  346 
//  347     if (interruptFlagMask & RTC_C_PRESCALE_TIMER0_INTERRUPT){
//  348         HWREG8(baseAddress + OFS_RTCPS0CTL_L) &= ~(RT0PSIFG);
//  349     }
//  350 
//  351     if (interruptFlagMask & RTC_C_PRESCALE_TIMER1_INTERRUPT){
//  352         HWREG8(baseAddress + OFS_RTCPS1CTL_L) &= ~(RT1PSIFG);
//  353     }
//  354 }
//  355 
//  356 uint16_t RTC_C_convertBCDToBinary (uint16_t baseAddress,
//  357     uint16_t valueToConvert)
//  358 {
//  359     HWREG16(baseAddress + OFS_BCD2BIN) = valueToConvert;
//  360     return ( HWREG16(baseAddress + OFS_BCD2BIN) );
//  361 }
//  362 
//  363 uint16_t RTC_C_convertBinaryToBCD (uint16_t baseAddress,
//  364     uint16_t valueToConvert)
//  365 {
//  366     HWREG16(baseAddress + OFS_BIN2BCD) = valueToConvert;
//  367     return ( HWREG16(baseAddress + OFS_BIN2BCD) );
//  368 }
//  369 
//  370 #endif
//  371 //*****************************************************************************
//  372 //
//  373 //! Close the doxygen group for rtc_c_api
//  374 //! @}
//  375 //
//  376 //*****************************************************************************
// 
//
// 
//
//
//Errors: none
//Warnings: none
